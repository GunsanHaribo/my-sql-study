# 키워드

# 질문

# 단원정리
## 1. 디스크 읽기 방식
- 하드 디스크 드라이브는 기계식 장치여서 DB에서는 항상 디스크 장치가 병목이 됨, 디스크는 SSD를 많이 사용
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정
- 쿼리 튜닝 : 랜덤 I/O 자체를 줄인다 = 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선
- 랜덤 I/O, 순차 I/O
   - 랜덤 io는 시스템 콜을 3번 요청
## 2. 인덱스란?
- 데이터의 저장(Insert, Update, Delete) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- 인덱스를 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정
1. 알고리즘별 분류(B-Tree, Hash)
- B-Tree 인덱스
- Hash 인덱스
  - 칼럼의 값으로 해시값을 계산, 값 전체를 해시로 변환해서 사용
2. 중복 여부로 분류(유니크와 유니크하지않음)
- 유니크 인덱스에 대해 동등 조건으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효과를 낸다.
## 3. B-Tree 인덱스
- 최상위 : 루트노드, 가장 하위 : 리프 노드, 중간 노드 : 브랜치 노드
1. 인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가진다.
- InnoDB는 프라이 머리 키가 ROWID 역할을 합니다.
  - 데이터 파일을 바로 찾아가지 못하고
  - 프라이머리 키 인덱스를 한번 더 검색후, 프라이머리 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다. = 모든 세컨더리 인덱스는 프라이머리 키 인덱스를 한번 더 조회해야함
2. 인덱스 키 추가 및 삭제
   1. 추가 
      - 추가하는 작업은 테이블의 칼럼수, 칼럼의 크기, 인덱스 칼럼의 특성 등을 확인 -> 리프노드 이동해야되서 쓰기 작업이 비용이 큼
      - 대략적인 계산은 테이블에 레코드를 추가하는 비용을 1이라고하면, 인덱스에 키를 추가하는 작업 비용을 1.5로 예측
      - 대부분의 시간은 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야되서 걸리는 시간
   2. 삭제
      - 삭제 마킹
   3. 변경 
      - 삭제후, 다시 래오운 키 값을 추가하는 형태
   4. 검색 
      - 100% 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우에 사용할 수 있다.
      - 이미 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 인덱스에 존재하는 값이 아니므로, B-Tree의 장점을 이용할 수 없으므로 주의
      - innoDB에서는 레코드락이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 방식으로 구현되어있어서 update, delete에서 인덱스가 없을 경우 불필요하게 많은 레코드를 잠글 수 있습니다.
3. B-Tree 인덱스 사용에 영향을 미치는 요소
   1. 인덱스 키 값의 크기
      - 인덱스를 구성하는 키값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어나고, 그만큼 느려진다.
        - 한페이지에 담을 수 있는 인덱스의 양이 줄어듬
      - 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미
        - 레코드를 위한 인덱스 크기가 커지면 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다
   2. B-Tree 깊이
      - 인덱스 키값을 줄려서 인덱스 페이지가 가능한 많은 인덱스 키를 담을 수 있게 해야 depth가 낮아져서 디스크 읽기를 수월하게 할 수 있다.
   3. 선택도(기수성)
      - 모든 인덱스 키 값 가운데 유니크한 값의 수
      - 전체 인덱스 키 값은 100개인데, 그중에서 유니크한 값의 수는 10개라면, 기수성은 10
      - 하나의 키 값으로 검색했을떄 대략 몇건의 레코드가 일치 할지 예측하는 예제가 있음
        - 다만, 이구절이 이해가 가지 않음, 전체 레코드 건수를 유니크한 값의 개수로 나눠보면 하나의 키값으로 검색했을떄 대략 몇건의 레코드가 일치할지 예측할 수 있게 된다.
   4. 읽어야 하는 레코드의 건수
      - 전체 테이블을 모두 읽어서 필요없는 50만건을 버리는것이 효율적인지 인덱스를 통해 필요한 50만건만 읽어 오는 것이 효율적인지
      - 손익 분기점은 20~25%를 넘어서면 인덱스를 이요하지 않고, 테이블을 모두 직접 읽어서 피룡한 레코드만 가려내는(필터링) 방식으로 처리
4. B-Tree 인덱스를 통한 데이터 읽기
   1. 인덱스 레인지 스캔
      - 인덱스 seek : 조건이 만족한느 값이 저장된 위치 찾기 -> 인덱스 스캔 : 탐색된 위치부터 필요한만크 인덱스를 쭉 읽기 -> 스캔을 통해 읽은 인덱스키와 레코드 주소를 사용해 레코드 저장 페이지 + 최종 레코드 읽어옴 
   2. 인덱스 풀스캔
      - 인덱스의 처음부터 끝까지
      - 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번쨰 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용 (A,B,C)일떄 BC로만 검색했을떄
   3. 루스 인덱스 스캔
      - 듬성듬성 읽기
      - Group By 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용
        - ex) 그룹한 것의 첫번쨰 레코드만 읽어도 되는경우
   4. 인덱스 스킵스캔(보강 필요)
      - Where 조건절의 검색을 위해 사용
      - 조건을 건너 뛸 수 있음을 의미
   5. 다중 칼럼 인덱스
      -  2개 이상의 칼럼을 포함하는 인덱스
5. B-Tree 인덱스의 정렬 및 스캔 방향 
   1. 인덱스의 정렬
      - 원래는 방향 설정이 안됬으나, 이제는 정렬 순서를 혼합한 인덱스도 생성할 수 있게됨
   2. 인덱스 스캔 방향
      - 옵티마이저가 알아서 진행 
      - 인덱스 생성 시점에 오름차순 또는 내림 차순으로 정렬이 결정 되지만, 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다 .
        - desc면 인덱스를 역순으로 읽는 다는 등등..
   3. 내림 차순 인덱스
      - 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수 밖에 없는 이유
        - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
        - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
      - 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하느 것이 잠금 병목 현상을 완화할 수 있다.
6. B-Tree 인덱스의 가용성과 효율성 
- Where, Group Bt, Order By 절이 어떤 경우에 인덱스를 사용할 수 있고, 어떤 방식으로 사용할 수 있는지
   1. 비교 조건의 종류와 효율성 
      - (보강 필요, 이해가 안감)
   2. 인덱스의 가용성
      - left-most
   3. 가용성과 효율성 판단
      - 교재에서는 6가지정도 사용못할떄가 나옵니다.
      - 작업 법위 결정 조건으로 인덱스를 사용할 수도 있다고 하고 예제도 나옴
## 4. R-Tree 인덱스
- 공간 인덱스에서 사용
- 기하학적 도형 정보르 관리할 수 있는 데이터 타입을 제공
- 각 도형의 포함 관계를 이용해 만들어진 인덱스, St_contains 또는 st_within()등과 같은 포함 관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스 사용
  - ex) 현재 사용자의 위치로부터 반경 5km이내 음식점 검색