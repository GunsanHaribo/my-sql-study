# 키워드

# 질문

# 단원정리

## 5. 전문 검색(Full Text search) 인덱스(즁요)
- 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문(Full Text) 검색
1. 인덱스 알고리즘 
   1. 어근 분석 알고리즘
      - 불용어 처리 : 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업
      - 어근 분석 : 단어의 뿌리인 원형을 찾는 작업, 단어 사저느 문장 구조 인식 필요 
   2. n-gram 알고리즘
      - 키워드를 검색해내기 위한 인덱싱 알고리즘
      - 2자씩 토크나이즈함, 공백을 제외하는드스 중복된 토큰은 하나의 인덱스 엔트리로 병합
   3. 불용어 변경 및 삭제
      - that -> ha, ta는 버려지는데, a가 불용어로 있으면, 이 기능이 혼란스러울수도 있음 -> 비활성화 추천
      - 사용자 정의 불용어 사용
        - 텍스트 파일로 등록
        - 시스템 변수에 불용어 테이블을 등록
2. 전문 검색 인덱스의 가용성
   - 전문 검색을 위한 문법(Match---against)을 사용, 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유
   - %애플% 이런거 처리할거면 -> Match against 구문 사용해야합니다.
## 6. 함수 기반 인덱스
1. 칼럼의 값을 변형해서 만들어진 값에 대한 인덱스
   - 가상 칼럼을 이용한 인덱스
     - first+lastName 이 결합된 가상 컬럼
   - 함수를 이용한 인덱스
     - 가상 컬럼을 추가 하는 것 말고 Concat을 사용해서 인덱스도 사용가능 
   - 다른 방식으로 같은 결과(위와 같이 성+이름)일떄 성능은 같습니다.
## 7. 멀티 벨류 인덱스
- 하나의 데이터 레코드가 여러개의 키 값을 가질 수 있는 형태의 인덱스
- Json 배열 타입의 필드에 인덱스 요건 발생  -> JSON 배열의 각 값마다 id(행의 PK)가 매핑된 인덱스
- member of, json_contains, json_overlaps() 같은 문법 필요
## 8. 클러스터링 인덱스(중요)
- 비슷한것들을 동시에 조회하는 경우가 많다는 점에서 착안 
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현
- 리프노드에 범위안에 있는 값들이 저장되어 있다. 
## 9. 유니크 인덱스 
- 일반 인덱스랑 같으나, 하나만 있는지 체크하는것, 
  - 느림, 중복되 값체크할떄는 읽기 잠금, 쓰기할떄는 쓰기잠금 이 과정에서 데드락이 빈번히 발생
  - 성능이 더 좋을 것이라고 생각하지않는 것을 추천
## 10. 외래키
- 외래키 : 부모-자식, 부모가 있으면 자식은 지워지지않음(조건부), 삭제됐을 때 같이 삭제돼야 하는 걸 묶는 것
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성
- 변경(쓰기 잠금)이 발생하는 경우에만 잠금경합이 발생
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠근 경합(잠금 대기)을 발생시키지 않는다
- 외래키를 생성하면 해당 참조키가 부모테이블에 있는지 확인 하는데, 이떄, 연관 테이블에 읽기 잠금을 건다. 
1. 자식 테이블의 변경이 대기하는 경우
   - 자식 테이블의 외래키 칼럼 변경(insert, update)는 부모 테이블의 확인이 필요한데, 이상태에서 부모테이블의 해당 레코드가 쓰기 잠금이 걸려있으면, 해당 쓰기 잠금이 해제될떄까지 기다리게 되는 것
   - 자식 테이블의 외래키가 아닌 컬럼 값의 변경은 위와 같이 잠금 확장이 되지 않는다.
2. 부모 테이블의 변경 작업이 대기하는 경우 
   - 2번 커넥션이 tb_parent에서 1인 레코드를 삭제하는 경우 tb_child 테이블의 레코드에 대한 쓰기 잠금이 해제될 떄까지 기다려야한다(ON DELETE CASADE 떄문)