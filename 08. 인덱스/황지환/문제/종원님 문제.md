1. 인덱스를 테이블에 많이 추가할수록 데이터의 저장속도는 더 빨라진다.
O / X
2. InnoDB 테이블은 기본적으로 프라이머리 키(Primary Key)를 기준으로 데이터가 정렬되어 디스크에 저장된다.
O / X
어댑티브 해시 인덱스는 사용자가 자주 요청하는 데이터에 대해 InnoDB 엔진이 자동으로 생성해주는 인덱스다.
O / X
R-Tree 인덱스는 일반적인 문자열 검색의 속도를 높이기 위해 사용하는 공간 인덱스다.
O / X
B-Tree 인덱스를 검색할 때, 인덱스를 구성하는 칼럼 값의 크기가 클수록 검색 성능에 유리하다.
O / X
인덱스는 데이터 저장 성능을 일부 희생하는 대신, 데이터 (------) 성능을 높이는 기능
InnoDB 테이블의 모든 레코드는 기본적으로 (-------) 순서대로 디스크에 정렬되어 저장
B-Tree 인덱스에서 중복된 값이 적고 유니크한 값의 수가 많을수록 (------)가 높다고 하며, 이는 검색 성능 향상에 도움이 된다.
InnoDB의 (-------)는 인덱스 변경 작업을 바로 처리하지 않고 임시 공간에 저장해두었다가 나중에 처리함으로써 디스크 I/O를 줄여주는 역할을 한다.
가장 일반적으로 사용되는 인덱스 알고리즘은 (------) 인덱스이다.



# 해답
X, 인덱스는 데이터 읽기(조회) 성능을 높이는 기능임. 데이터를 저장(INSERT, UPDATE, DELETE)할 때는 인덱스에도 변경된 내용을 반영해야 하므로, 인덱스가 많을수록 저장 과정이 복잡해지고 속도 느려짐
O, InnoDB 테이블은 '프라이머리 클러스터링 테이블' 구조를 가지며, 이는 프라이머리 키 순서대로 레코드가 디스크에 물리적으로 저장되는 것을 의미
O, 어댑티브 해시 인덱스는 사용자가 직접 생성하는 것이 아니라, InnoDB 엔진이 자주 사용되는 데이터에 대해 B-Tree 검색 시간을 줄이기 위해 자동으로 만들어주는 기능
X, R-Tree 인덱스는 2차원 공간 데이터를 처리하기 위한 인덱스
X, 인덱스 키 값의 크기가 커지면 하나의 인덱스 페이지에 저장할 수 있는 키의 개수가 줄어들게 되는데 이는 B-Tree의 깊이를 더 깊게 만들어 더 많은 디스크 읽기를 유발하게 됨
읽기
프라이머리 키(기본 키)
선택도 (기수성)
체인지 버퍼 (Change Buffer)
B-Tree (Balanced Tree)



# 제출
1. X
2. O
3. O
4. X
5. X
6. 조회
7. PK
8. 선택도(카디널리티)
9. 체인지 버퍼
10. B-tree

----

# 2부 문제 
1. 클러스터링 인덱스는 테이블의 프라이머리 키(Primary Key)에 대해서만 적용된다. (O / X)
2. 유니크 인덱스는 중복 체크 과정이 필요 없기 때문에 세컨더리 인덱스보다 쓰기 속도가 빠르다. (O / X)
3. 어근 분석 알고리즘은 단어 사전이나 언어 학습 없이도 만족할 만한 검색 결과를 얻을 수 있다. (O / X)
4. 외래 키(Foreign Key)를 설정하면, 연관된 칼럼에 인덱스가 자동으로 생성된다. (O / X)
5. 함수 기반 인덱스를 사용하더라도, WHERE 조건절에 인덱스 생성 시 사용한 함수 표현식을 그대로 쓰지 않아도 옵티마이저가 인덱스를 활용한다. (O / X)
6. 전문 검색 인덱스에서 검색 가치가 없는 단어를 제거하는 작업을 ~~ 처리라고 한다.
7. 본문을 무조건 n 글자씩 잘라서 인덱싱 하는 방법을 ~ 알고리즘이라고 하며, 주로 2글자씩 자르는 방식(Bi-gram)이 많이 사용된다.
8. ~~ 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태로, JSON 배열 타입의 필드에 사용하기 위해 지원되기 시작했다.
9. 유니크 인덱스는 ~ 작업 때문에 InnoDB 엔진의 '체인지 버퍼'를 사용하지 못해 쓰기 성능이 저하될 수 있다.
10. ~~ 인덱스는 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태로, 테이블 그 자체가 하나의 거대한 인덱스 구조로 관리된다.

# 제출 
1. o
2. x
3. x
4. o
5. x
6. 불용어 처리
7. n-gram
8. 멀티 벨류 인덱스
9. 쓰기
10. 클러스터링


# 답지 
1. O,  프라이머리 키에 대해서만 적용되는 내용
2. X, 중복 체크 과정이 필요해서 세컨더리 인덱스보다 쓰기 속도가 느림
3. X 만족할 만한 결과를 내기 위해 단어 사전과 언어 학습이 필요하고, 이 과정에 상당한 시간이 필요함
4. O 외래키 제약 설정 시 자동으로 연관된 테이블 칼럼에 인덱스가 생성
5. X 반드시 조건절에 명시된 표현식 그대로 사용해야 함
6. 불용어
7. n-gram
8. 멀티 밸류 (Multi-Value)
9. 중복 체크
10. 클러스터링 (Clustering)