# 문제 
1.  쿼리 튜닝의 핵심은 ( ) 자체를 줄이고, 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 개선하는 것이다.
2. 인덱스는 데이터의 ( ) 성능을 희생하고, ( ) 속도를 높이기 위한 기능이다.
3. InnoDB 스토리지 엔진에서 모든 세컨더리 인덱스는 ( ) 인덱스를 한 번 더 조회해야 실제 레코드에 접근할 수 있다.
4. 인덱스 레인지 스캔은 ( ) → ( ) → ( ) 순으로 진행된다.
5. 인덱스를 구성하는 키 값의 유니크한 정도를 ( ) 또는 ( ) 이라고 한다.
6. ( ) 인덱스는 공간(위치 기반) 데이터를 다루며, ST_Contains나 ST_Within 같은 포함 관계 함수에서만 사용된다.
7.  인덱스의 리프 노드는 실제 데이터 레코드를 직접 포함하고 있다. (O / X)
8. 인덱스의 키 값 길이가 길어질수록 인덱스의 크기가 커지고, 메모리(innoDB 버퍼풀)에 캐시할 수 있는 인덱스 수는 줄어든다. (O / X)
9. 인덱스를 이용한 검색은 항상 테이블 풀스캔보다 빠르다. (O / X)
10. 인덱스는 생성 시 오름/내림이 정해져 있어도 실행 시 역방향으로 스캔하여 반대 정렬 효과를 낼 수 있다. (O / X)

# 해답
1. 랜덤 I/O 
2. 저장 / 읽기
3. 프라이머리 키
4. 인덱스 시크(Seek) → 인덱스 스캔(Scan) → 테이블/PK 접근
5. 선택도 / 기수성
6. R-Tree
7. X  — 리프에는 레코드의 주소(또는 InnoDB에선 PK) 참조가 저장됨
8. O
9. 정답: X  — 대략 전체의 20~25% 이상을 읽으면 풀스캔이 유리할 수 있음
10. O  — 옵티마이저가 정/역순 스캔을 선택 가능