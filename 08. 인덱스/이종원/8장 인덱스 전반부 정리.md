# 개요
- MyISAM 기능이었던 전문 검색, 위치 기반 검색 기능 모두 InnoDB 엔진에서 사용 가능함

## 인덱스
- 인덱스 = 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(Key-Value)로 만든 것
- 칼럼의 값을 주어진 순서로 미리 정렬해서 보관함
	- 미리 정렬된 상태이기에 원하는 값을 빠르게 찾을 수 있음
	- 항상 값을 정렬해서 저장 해야 하기에 저장 과정이 복잡하고 느림
	- 즉, 데이터 저장 성능을 희생하고 읽기 성능을 높이는 기능
- 테이블 키 칼럼만 가지고 있으며 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드 찾아야 함
- 인덱스를 효율적으로 사용하다 = 인덱스를 이용하다

### 인덱스 추가로 인한 INSERT, UPDATE 영향
- 레코드 추가 비용을 1이라 가정하면 인덱스에 키를 추가하는 작업 비용은 1.5
- 3개의 인덱스가 있을 경우에는 1.5 X 3 + 1

## 프라이머리 클러스터링 테이블
- 기본키(프라이머리 키) 기준 클러스터링(군집)되어 저장
	= 기본키 순서대로 디스크 저장됨
- 모든 세컨더리 인덱스는 기본 키의 논리적 주소로 사용함
- 기본키 포함 모든 인덱스는 물리적인 레코드 주소값을 가짐

## 어댑티브 해시 인덱스 테이블
- InnoDB 엔진이 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- B-Tree 검색 시간을 줄여주기 위해 도입함
	- 자주 읽히는 데이터 페이지의 키 값을 이용해서 해시 인덱스를 만듬
	- 해시 인덱스 = B-Tree 인덱스 고유 번호(ID) : B-Tree 인덱스 실제 값
- 내부 잠금(세마포어) 경합을 줄이기 위해 파티션 기능 제공

실무
- 디스크 읽기 횟수 많은 경우, 특정 패턴 쿼리 많은 경우(조인, LIKE 패턴 검색), 매우 큰 데이터를 가진 테이블 레코드를 폭 넓게 읽는 경우 = 어댑티브 해시 인덱스 성능 향상 적음
- 디스크 데이터가 버퍼 풀 크기와 비슷한 경우, 동등 조건 검색이 많은 경우, 쿼리가 데이터 중 일부 데이터에만 집중되어 있는 경우 = 어댑티브 해시 인덱스 성능 향상 큼

## 체인지 버퍼
- 인덱스 페이지가 버퍼풀에 없을 때, 해당 인덱스 페이지에 적용되어야 할 변경 작업을 저장하는 임시공간
- 디스크 읽기 및 쓰기 작업을 최소화하는 역할 수행

# 인덱스 종류

## B-Tree 인덱스(Balanced Tree)
- 가장 일반적으로 사용되는 인덱싱 알고리즘
- 일반적인 DBMS에서는 주로 B+ Tree, B* Tree를 사용함
- 칼럼의 원래 값을 변형시키지 않거나 아주 조금 변형시킨 뒤 인덱스 구조체 내에서 항상 정렬된 상태 유지

### 구조 및 특성
- 루트 노드와 리프 노드, 브랜치 노드 등으로 구성되어 있음
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값 저장
- MyISAM 테이블에서 레코드 주소는 레코드가 테이블에 INSERT된 순번이거나 데이터 파일 내 위치(Offset)
	- 세컨더리 인덱스가 물리적인 주소를 가짐
- InnoDB 테이블에서는 프라이머리 키가 ROWID 역할 수행
	- 세컨더리 인덱스가 논리적인 주소를 가짐
		- Why? 프라이머리 키를 주소처럼 사용하기에
	- 레코드를 읽을 때, 바로 데이터 파일을 찾아가지 못함

### B-Tree 인덱스 키 추가 및 삭제
#### 키 추가
1. 저장될 키 값을 이용해 적절한 위치 검색
2. 저장될 위치 결정 시 레코드 키 값과 대상 레코드의 주소 정보를 B-Tree 리프 노드에 저장
	- 만약 리프 노드가 꽉 차서 저장할 수 없을 경우, 리프 노드를 분리(Split)함

- MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경함
- InnoDB에서는 필요 시 인덱스 추가 작업을 지연시켜 나중에 처리할 수 있음
	- 체인지 버퍼 작업

#### 키 삭제
- 리프 노드를 찾아서 삭제 마크만 하면 끝남
	- 디스크 I/O 작업 필요함
- 삭제 마킹된 인덱스 공간을 그대로 방치하거나 재활용 가능함
- MyISAM이나 MEMORY 스토리지 엔진에서는 인덱스 키 삭제 후 쿼리 실행됨
- InnoDB에서는 버퍼링되어 지연 처리 가능함

#### 키 변경
- 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리
- InnoDB 스토리지 엔진에서는 체인지 버퍼를 통해 지연 처리 가능함

#### 키 검색
- B-Tree 루트 노드부터 시작해 브랜치 노드 -> 최종적으로 리프 노드까지 이동하면서 비교 작업 수행
- UPDATE나 DELETE 처리를 위해 항상 해당 레코드 먼저 검색해야 할 경우에도 사용
- 100% 일치 혹은 값의 앞 부분만 일치하는 경우에 사용 가능
- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현됨
	- UPDATE나 DELETE 문장이 실행될 때, 테이블에 적절히 사용할 수 있는 인덱스가 없으면 많은 레코드를 잠그게 만듬

### 사용에 영향을 미치는 요소

#### 인덱스 키 값의 크기와 B-Tree 깊이
- 페이지(Page, 블록) = 디스크의 모든 읽기 및 쓰기 작업의 최소 기본 단위
	- InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위
- 인덱스의 B-Tree 구조가 가질 수 있는 자식 노드는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정됨
	- InnoDB 스토리지 엔진의 페이지 기본값 = 16KB
	- 인덱스 페이지가 16바이트라면 16 \* 1024/(16 + 자식 노드 주소) 개 저장 가능
- 인덱스를 구성하는 키 값의 크기가 커지면 내부에 저장할 수 있는 자식 노드의 수가 적어지고 이는 디스크를 여러 번 읽어야 하게 된다 => 속도 저하
	- 키 값이 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 이로 인해 B-Tree 의 깊이가 깊어져서 더 많은 디스크 읽기가 필요하게 됨
- 인덱스 키 값의 길이가 길어지는 것은 인덱스의 크기가 커지는 것 = InnoDB의 버퍼 풀이나 MyISAM 키 캐시 영역의 크기가 제한적이기 때문에 인덱스 크기가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어듬
- 가능한 키 값의 크기를 작게 만들면 좋음

#### 선택도(기수성)
- 선택도(Selectivity), 기수성(Cardinality)란 거의 같은 의미로 사용되며 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미함
- 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성과 선택도가 떨어짐
	- 선택도가 높을수록 검색 대상이 줄어듬 = 빠르게 검색 가능

#### 인덱스를 통해 읽어야 하는 레코드 건 수
- 인덱스를 통해 레코드 1건 읽는 것의 비용은 테이블에서 직접 레코드 1건을 읽는 거보다 4~5배 정도 비용이 더 많이 드는 작업으로 판단됨
	- 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인ㄷ게스를 이용하지 않고 테이블 모두 직접 읽어서 필요 레코드만 가려내는 방식으로 처리하는 것이 효율적임


### B-Tree 데이터 읽는 방법
#### 인덱스 레인지 스캔
- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
	- 검색하려는 값의 수나 검색 결과 레코드 건 수와 관계 없음
- 타이트(Tight) 인덱스 스캔으로 분류

##### 스캔 방식
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾음 = 인덱스 탐색(Index seek)
2. 시작해야할 위치를 찾으면 필요한 만큼 리프 노드의 레코드를 순서대로 읽어나감 = 인덱스 스캔(Index scan)
	- 리프 노드의 끝까지 읽으면 리프 노드 간 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔 시작함
	- 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝냄
	- 어떤 방식으로 스캔하든 관계없이 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져옴
- 3. 인덱스의 리프 노드에서 검색 조건에 일치하는 건들을 데이터 파일에서 레코드로 읽어올 때, 레코드 한 건마다 랜던 I/O 이루어짐

```SQL
SHOW STATUS LIKE 'Handler_%'
```
- 위 명령어로 레인지 스캔의 각 단계가 어떻게 이루어졌는 지 알 수 있음
	- 1번 작업 = Handler_read_key
	- 2번 작업 = Handler_read_next, Handler_read_prev

#### 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우에 사용됨
- 타이트(Tight) 인덱스 스캔으로 분류

##### 스캔 방식
1. 인덱스 리프 노드의 제일 앞 또는 뒤로 이동
2. 인덱스의 리프 노드를 연결하는 연결 리스트를 따라서 처음부터 끝까지 스캔

#### 루스 인덱스 스캔
- 오라클과 같은 DBMS의 인덱스 스킵 스캔과 작동 방식 비슷
- 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태
	- GROUP BY 또는 집합 함수 가운데 MAX, MIN 함수의 최적화를 하는 경우에만 사용

#### 인덱스 스킵 스캔
- 인덱스를 구성하는 키 값중에서 특정 칼럼이 없더라도 하나의 칼럼만으로 인덱스 검색을 가능하게 해주는 기능
- MySQL 8.0부터 도입
```SQL
SET optimizer_switch ='skip_scan = on';
```
- 위 명령어로 인덱스 스킨 스캔 활성화 가능함
- WHERE 조건절에 조건이 없는 인덳의 선행 칼럼의 유니크한 값의 개수가 적어야 효율적임
	- 많다면 스캔해야 할 시작 저짐을 검색하는 작업이 많아짐
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

### 다중 칼럼 인덱스(Balanced Tree)
- 두 개 이상의 칼럼으로 구성된 인덱스를 의미함

### 인덱스 정렬 및 스캔 방향
#### 인덱스 정렬
- 일반적인 상용 DBMS는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 혹은 내림차순으로 설정 가능함
- MySQL 5.7버전까지는 칼럼 단위로 정렬 순서를 혼합(ASC, DESC 혼합)해서 인덱스 생성 불가능함
- MySQL 8.0버전부터는 순서를 혼합해서 생성 가능해짐
```SQL
CREATE INDEX 인덱스명 ON 테이블명(칼럼명1 ASC, 칼럼명2 DESC);
```

#### 인덱스 스캔 방향
- 인덱스 생성 시점, 오름차순, 내림차순 정렬이 결정되지만 쿼리가 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순, 내림차순 정렬 효과를 얻을 수 있음

## R-Tree 인덱스
- 공간 인덱스(Spatial Index) = R-Tree 인덱스 알고리즘을 이용해 2차원 데이터를 인덱싱하고 검색하는 목적의 인덱스
	- 2차원의 공간 개념값을 인덱스로 사용함
	- GIS, GPS 등의 위치 기반 서비스에 사용됨
- MySQL에서는 공간 확장(Spatial Extension) 기능이 존재함
	- 공간 데이터를 저장할 수 있는 데이터 타입
	- 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
	- 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

### 구조 및 특성
- POINT, LINE, POLYGON, GEOMETRY 라는 데이터 타입을 지원함
- Minimum Bounding Rectangle(MBR) = 해당 도형을 감싸는 최소 크기의 사각형
- R-Tree 인덱스 = 최소 크기의 사각형들의 포함 관계(MBR)를 B-Tree로 구현한 인덱스
- MBR을 3개의 레벨로 나눔
	- 최하위 레벨의 MBR은 각 도형 데이터의 MBR
	- 차상위 레벨의 MBR은 중간 크기의 MBR(각 도형 객체의 그룹)
	- 최상위 MBR은 R-Tree 루트 노드에 저장되는 정보

### R-Tree 인덱스의 용도
- 일반적으로 WGS84(GPS) 기준 위도, 경도 좌표 저장에 주로 사용됨
	- CAD/CAM 소프트웨어, 회로 디자인 등과 같이 좌표 시스템 기반을 둔 정보에 대해서도 적용 가능
- ST_Contains() 또는 ST_Within() 등과 같은 포함 관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스 이용 가능함
	- ex) 현재 사용자 위치로부터 반경 5Km 이내 음식점 검색 등에 사용 가능함
- ST_Distance() 나 ST_Distance_Spher() 함수는 공간 인덱스를 효율적으로 사용하지 못함

# 기타
- 큰 테이블의 레코드 대부분을 읽는 작업에서는 풀 테이블 스캔 사용하도록 유도함
	- OLTP(On-Line Transaction Processing) 성격의 웹서비스보다 데이터 웨어하우스나 통계 작업에서 자주 사용함
- InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장 => 프라이머리 키 순서로 정렬되어 저장함
	- **사용자가 별도 명령이나 옵션 선택ㅎ사지 않아도 디폴트로 클러스터링 테이블 생성됨**
	- 오라클의 IOT(Index Organized Table)이나 MS-SQL 클러스터 테이블과 같은 구조
	- 