# 전문 검색 인덱스
- 문서 내용 전체를 인덱스화하는 방식
- 특정 키워드가 포함된 문서를 검색할 때 주로 사용됨
- 문서 전체에 대한 분석과 검색을 위한 알고리즘으로는 어근 분석, n-gram 분석 알고리즘이 존재함


## 어근 분석 알고리즘
- 불용어 처리 이후 어근 분석을 통해 색인 작업을 진행하는 알고리즘
	- 불용어 처리란, 가치 없는 단어를 제거하는 작업
	- 어근 분석이란, 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
- 만족할 만한 결과를 내기 위해서는 1. 단어 사전 필요, 2. 문장 구조 인식을 위한 언어 학습 필요한데 이 과정이 상당한 시간이 필요로 함

## n-gram 알고리즘
- 본문을 무조건 n 글자씩 잘라서 인덱싱 하는 방법
	- 주로 2-gram(Bi-gram) 방식을 많이 사용

### 2-gram 알고리즘 로직
1. 띄어쓰기(공백), 마침표(.)를 기준으로 2글자씩 중첩해서 토큰 분리
2. 각 토큰에 대해 불용어 처리 진행
3. 최종적으로 남은 토큰을 B-Tree 인덱스에 저장


## 불용어 변경 및 삭제 방법
### 삭제
1. MySQL 서버 설정 파일(my.cnf)의 ft_stopword_file 시스템 변수에 빈 문자열 설정
2. innodb_ft_enable_stopword 시스템 변수를 OFF로 설정

### 사용자 정의 불용어
1. MySQL 서버 설정 파일(my.cnf)의 ft_stopword_file 시스템 변수에 불용어 파일 목록 경로를 저장
2. 불용어 목록을 테이블로 저장, innodb_ft_server_stopword_table 시스템 변수에 불용어 테이블 설정

# 함수 기반 인덱스
- 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축하는 것

## 가상 칼럼을 이용한 인덱스(8.0 이후)
```SQL
ALTER TABLE 테이블명
	ADD 가상 필드명 타입명 VIRTUAL
	ADD INDEX 인덱스명 (가상 필드명)
```
- VIRTUAL을 추가해서 가상 필드를 만들고 그 가상 칼럼에 인덱스 생성하는 방식

## 함수를 이용한 인덱스
```SQL
CREATE TABLE 테이블명(
	필드명 타입명,
	INDEX 인덱스명 (함수))
```
- 반드시 조건절에 함수 기반 인덱스에 명시된 표현식 그대로 사용되어야 함
	- ex) INDEX ix_fullname ((CONCAT(first_name, ' ', last_name))) 이라면 CONCAT 함수를 그대로 WHERE 절에 집어넣어야 함
	  ```SQL
	  SELECT * FROM 테이블명 WHERE CONCAT(first_name, ' ', last_name) = "찾을 값";
	  ```


# 멀티 밸류 인덱스
- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스
- JSON 배열 타입의 필드에 대한 인덱스 요건때문에 지원하기 시작
- 멀티 밸류 인덱스를 사용하기 위해서는 아래 3개 함수를 이용해 검색해야만 옵티마이저가 실행계획을 수립함
	- MEMBER OF( )
	- JSON_CONTAINS( )
	- JSON_OVERLAPS( )

# 클러스터링 인덱스
- 클러스터링이란, 여러 개를 하나로 묶는다는 의미
- MySQL 서버에서의 클러스터링이란, 테이블의 레코드를 비슷한 것들끼리 묶어서 저장하는 형태로 구현
	- 리프 노드에 레코드의 모든 칼럼이 같이 저장됨
	- 클러스터링 테이블 그 자체가 하나의 거대한 인덱스 구조로 관리됨
- 클러스터링 인덱스와 클러스터링 테이블은 동의어로 사용됨
- 프라이머리 키에 대해서만 적용되는 내용
	- 프라이머리 키 값이 변경된다면 그 레코드의 물리적 저장 위치가 바뀌어야 한다는 것을 의미함
	- 프라이머리 키 기반 검색은 매우 빠르지만, 레코드 저장이나 프라이머리 키 변경이 상대적으로 느림


# 유니크 인덱스
- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없는 인덱스
	- MySQL에서는 프라이머리 키는 기본적으로 NULL 허용되지 않는 유니크 속성 자동 부여

## 세컨더리 인덱스와 비교
### 인덱스 읽기
- 유니크 인덱스와 세컨더리 인덱스는 읽기 성능의 차이는 미미함


### 인덱스 쓰기
- 유니크 인덱스의 키 값을 쓸 때는 중복 체크 과정이 필요해서 세컨더리 인덱스보다 느림
- 추가적으로 MySQL에서는 중복 체크할 때는 읽기 잠금, 쓰기 할 때는 쓰기 잠금으로 인해 데드락이 빈번하게 발생함
- InnoDB 엔진에서는 체인지 버퍼가 사용되는데 유니크 인덱스는 중복체크 때문에 버퍼링을 하지 못해서 더 느리게 작동하게 됨

# 외래키
- InnoDB 엔진에서만 생성할 수 있음
- 외래키 제약 설정 시 자동으로 연관된 테이블 칼럼에 인덱스 생성
- 외래키 제거되지 않은 상태에서 자동 생성된 인덱스 삭제할 수 없음

## 관리 유의점
- 테이블 변경(쓰기 잠금) 발생 시, 잠금 경합(잠금 대기) 발생함
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)를 발생시키지 않음
