정렬, 집합의 explain의 경우

# 단원정리
## 1. 개요
### 1. 쿼리 실행 절차
- 1. 파싱, 2. 인덱스 선택 -> 실행계획 3. 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
### 2. 옵티마이저의 종류
- 비용기반 최적화
  - 쿼리 처리를 위한 여러가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
- 규칙 기반 최적화
  - 옵티마이저에 내장된 우선 순위에 따라 실행계획
## 2. 기본 데이터 처리
### 1. 풀 테이블스캔과 풀 인덱스 스캔
1. 풀테이블 스캔
   - 테이블의 레코드 건수가 너무 작은 경우
   - 레인지 스캔을 하더라도, 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
2. 풀테이블 스캔은 디스크로부터 페이지를 하나씩 읽어오지 않는다
   - 몇개를 포그라운드 스레드로 읽다가, 특정 시점부터는 읽기 작업을 백그라운드 쓰레드로 넘긴다.
   - 이렇게 미리 버퍼풀에 준비된 데이터를 가져다 사용하기만 하면 됨
   - innodb_read_ahead_threshold 시스템 변수에 설정 된 개수만큼의 연속된 페이지가 읽히면, 백그라운드 스레드로 버퍼풀로 적재
- Count()로는 풀인덱스 스캔가능, 레코드 수만 찾으면 되니깐. 다만 *로 하면 다른 칼럼 정보가 필요해서 풀테이블 스캔
### 2. 병렬처리
- 하나의 쿼리를 최대 몇개의 스레드로 가져오게 할 것인지
- 현재는 select쿼리에서면 병렬처리 가능, 스레드 수가 CPU 코어개수를 넘어서면 성능이 오히려 떨어질 수 있음
### 3. ORDER BY 처리(Using filesort)
- 인덱스 이용   
- Filesort이용 
  - 정렬 기준이 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과르 정렬해야하는 경우
  - Union의 겨로가 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
  - 랜덤하게 결과 레코드를 가져와야 하는 경우
- 인덱스를 이용하지 않고 별도의 정렬처리를 수행했는지는 Using filesort 메세지가 표시되는지 여부로 판단
1. 소트버퍼
   - 정렬을 수행하기 위한 별도의 메모리 공간
   - 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공강보다 크면, 레코드를 여러 조각으로 나눠서 정렬을 수행하고 그 결과를 임시로 디스크에 기록
   - 그 다음에 레코드를 가져와서 다시 정렬하면서 반복적으로 디스크에 임시 저장 -> 병합 정렬 필요
   - 다만, 버퍼 사이즈가 크면, 리눅스 계열에서는 큰 메모리 공간 할당 떄문에 성능이 떨어질 수도 있다.
   - 소트 버퍼는 세션 메모리 영역에 해당되며, 여러 클라이언트가 공유할 수 없다. 그래서 여러커넥션에서 동시에 정렬이 실행되면 oom 문제 발생가능한데, 
     - oom은 메모리를 가장 많이 먹는 프로세스르 강제 종료하기 떄문에 일반적으로 메모리를 가장 많이 사용하는 MySQL 서버가 강제 종료 1순위가 된다. 
2. 정렬 알고리즘
   1. 싱글 패스 
      - Select 대상이 되는 칼럼 전부를 담아서 정렬을 수행
   2. 투패스
      - 정렬 대상이 되는 데이터만 먼저 읽고 정렬 후, 다른 데이터를 테이블에서 다시 조회한다
   3. 정렬 처리 방법
      - 인덱스를 이용한 정렬
        - 인덱스에 있는 정보를 그대로 가져옴
        - 해시 인덱스나 전문 검색 인덱스에는 사용 불가, 조인이 있는 경우 네스티드-루프 방식을 조인에서만 사용가능
          - 조인이 네스티드-루프 방식의 조인이기 떄문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.
        - 다만, 실행계획에 조인 버퍼가 있으면 순서가 흐트러질 수 있다.
      - 조인에서 드라이빙 테이블만 정렬(Using filesort)
        - 조인을 실행하기전에 첫번 쨰 테이블 레코드를 먼저 정렬한 다음 조인을 실행
      - 조인에서 조인 결과를 임시 테이블을 이용한 정렬(Using temporary; Using filesort)
        - 조인의 드라이빙 테이블이 아니라, 드리븐 테이블에 정렬 포인드가 있을떄
        - 조인된 결과를 임시 테이블로 저장 후 정렬
   4. 정렬처리 방법의 성능 비교(인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동하는지)
      - 스트리밍 방식
        - 레코드가 검색될때마다 바로바로 전송
      - 버퍼링 방식
        - orderBy, GroupBy에서는 쿼리의 결과가 스트리밍 되는 것이 불가
        - 이떄 클라이언트가 기다려야되서 버퍼링
      - 인덱스를 사용한 정렬을 제외하고 다 버퍼링 방식
      - 가능하다면, 인덱스를 사용한 정렬로 유도하고, 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하기
   5. 정렬 관련 상태 변수
      - merge 몇번했는지, 레인지 스캔 몇번했는지 알수 있다.
### 4. GROUP By 처리
- 인덱스만 사용하는 건 불가 -> 집계한다음 결과 반환해야되서
- 인덱스를 이용할떄는 인덱스를 차례대로 읽는 인덱스 스캔방법
- 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔
- 인덱스를 사용하지 못하면 임시테이블 사용
1. 인덱스 스캔을 이용하는 GroupBy
   - 조인 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할떄
   - Using index for group-by, using temporary, Using filesort가 표시되지 않는다
2. 루스 인덱스 스캔을 이용하는 Group By
   - 인덱스 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미
   - 단일 테이블 에서만 사용가능
   - (emp_no, from_date) 인덱스에서 루스 인덱스 스캔을 어떻게 하는지 예제가 나옴
3. 임시 테이블을 사용하는 Group By
   - 인덱스를 전혀 사용할 수 없을떄 사용
   - Using temporary 라는 메세지가 표시
### 5. DISTINCT 처리
- 집합함수르 사용하는 경우랑 그렇지 않은 경우, 
- 집합함수랑 같이 distinct를 사용하면 임시 테이블을 사용하나, Using temporary 메세지가 띄지 않음
1. Select DISTINCT...
   - DISTINCT를 사용할떄는 레코드(튜플)을 유니크하게 하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아니다.
   - (first_name), last_name -> (first_name, last_name)으로 괄호는 의미가 없다.
2. 집합 함수와 함께 사용된 DISTINCT
   - 인덱스가 있으면 인덱스로 처리가능, distinct+집계함수면 임시테이블 사용
### 6. 내부 임시 테이블 활용
- 정렬하거나 그루핑할떄 사용, 다른 세션이나 다른 쿼리에서 볼 수도 없음
1. 메모리 임시테이블과 디스크 임시 테이블
   - 메모리는 TempTable이라는 스토리지 엔진, 디스크에 저장되는 테이블은 InnoDB 스토리지 엔진을 사용하도록 개선
   - 메모리의 임시테이블이 1기가 이상으로 커저서 디스크로 기록을 해야할떄는 아래 두가지 방식이 있음
     - MMAP 파일로 디스크에 기록 
     - InnoDB 테이블로 기록
2. 임시 테이블이 필요한 쿼리
   1. ORDER와 Group By에 병시된 칼럼이 다른 쿼리
   2. ORDER By나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫번쨰 테이블이 아닌 쿼리
   3. DISTINCT와 ORDER BY갇 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
   4. Union이나 Union Distict가 사용된 쿼리(select_type 칼럼이 union result인 경우)
   5. 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리
3. 임시 테이블이 디스크에 생성 되는 경우
   - 길이가 512 바이트 이상인 크기의 카럼이 있는 경우
4. 임시 테이블 관련 상태 변수
   - 이런게 있다.
## 3. 고급 최적화
- 조인 관련된 옵션과 옵티마이저 스위치 옵션이 있음
1. 옵티마이저 스위치옵션
  1. MRR(Multi-Range Read)과 배치 키 엑세스
     1. 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링 하는 것
  2. 블록 네스티드 루프 조인
     1. 조인 버퍼가 사용되는지 여부, 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인 되는가
     - Block = 별도의 버퍼가 사용됐다는 것을 의미
     - 인덱스가 없다면 풀테이블 스캔을 해야되는데 이러면 시간이 오래 걸리니, 
     - 드라이빙 테이블의 내용을 메모리에 캐시(조인 버퍼에 캐시) 한 다음, 드리븐테이블을 머저 읽고, 조인 버퍼에서 일치하는 레코드를 찾는 방식으로
     - 이 부분에서는 정렬순서가 흐트러질 수 있다.
  - 해시 조인 알고리즘이 사용 가능해져서 조인 알고리즘이 대체되어 사용됩니다.
  3. 인덱스 컨디션 푸시다운(index_condition_pushdown)
     - 인덱스를 쓸 수 없는 쿼리에서 관련 데이터를 모두 읽는 과정을 줄이기 위해서 
     - 모든 데이터를 끌어오는 과정을 줄이려고, 인덱스에 포함된 칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달
     - 이전에서는 MySQL에서 바로 실행했으나, 이제는 스토리지 엔진에서 인덱스 조회할때 조건도 한번에 보냅니다. 
  4. 인덱스 확장(use_index_extensions)
     - 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 사용할 수 있게 하는것
     - 세컨더리 인덱스에 자동으로 pk가 붙는데, (보조 인덱스 키) + (프라이머리 키)
     - 이전에는 pk를 사용 못해서, 한번 더 pk lookup을 했어야했다.
  5. 인덱스 머지(index_merge)
     - 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리
     6. 인덱스 머지-교집합(index_merge_intersection)
        - 옵티마이저가 각각의 조건에 일치하는 레코드 건수를예측해본 결과, 두 조건 모두 상대적으로 많은 레코드를 가져와야할떄
     7. 인덱스 머지-합집합(index_merge_union)
        - 합집합을 이용한 최적화
        - 다만, 중복을 제거하기 위해서는 정렬 작업이 필요했을 텐데... -> 정렬작업으로 중복제거를 한 이유? 왜 해시는 쓰지 않았지?
        - 아무튼 힙을 사용해서 그렇게 정렬하더라
     8. 인덱스 머지-정렬 후 합집합(index_merge_sort_union)
        - 인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우
        - 인덱스 결과들이 rowid로 정렬되 있지 않을떄, 그 결과를 rowid순으로 임시로 정렬한 후 합쳐서 중복을 제거하느 방식
  9. 세미 조인(semijoin)
     - 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없느니만 체크하는 형태의 쿼리
     -  = "", In, <>, Not In 형태의 최적화 방식이 있고, 서브쿼리 최저고하 중에서 세미 조인 최적화에 대해서만 살펴보겠다. -> 아래 5가지 
     10. 테이블 폴-아웃(Table Pull-out)
         - 서브 쿼리에 사용된 테이블을 아우터 쿼리로 끄집어 낸 후에 쿼리르 조인 쿼리로 재작성
         - In 형태의 서브 쿼리에서 많이 사용
     11. 퍼스트 매치(firstmatch)
         - In형태의 세미조인을 Exists 형태로 튜닝한 것과 비슷한 방법
         - 서브 쿼리가 아닌 조인으로, 일치하는 조인 중에 일치하는 첫번쨰 레코드만 검색하는 최적화
         - 있으면 바로 반환하는 최적화임
     12. 루스 스캔(loosescan)
         - GroupBy할떄 사용되는 스캔
     13. 구체화(Materialization)
         - 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미
         - 서브 쿼리가 상관 쿼리가 아니여야한다
     14. 중복제거(Duplicated Weed-out)
         - 서브 쿼리를 일반적인 Inner Join 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드르 제거하는 방법
         - 서브 쿼리가 상관 서브쿼리여도 사용가능하다
         - Group By나 집합 함수가 사용된 경우에는 사용될 수 없다.
  15. 컨디션 팬아웃(condition_fanout_filter)
      - 조건에 일치하는 레코드 건수가 적은 순서대로 조인을 실행 -> 네스트
      - fanout : 조인 후 결과가 얼마나 커지는지 -> 작은 쪽 부터 시작
      - 레코드의 통계를 기반으로 계산 합니다.
  16. 파생 테이블 머지(derived_merge)
      - 예전에는 From 절에 사용된 서브쿼리는 먼저 실행해서 그 결과를 임시 테이블로 처리
      - 임시 테이블로 레코드를 복제하는 오버헤드가 생겨서
      - 서브쿼리를 외부 쿼리로 병합하는 작업을 DBA가 수작업으로 처리
  17. 인비저블 인덱스
      - 인덱스의 가용 상태를 제어가능
  18. 스킵 스캔
      - 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능
  19. 해시 조인
      - 첫번쨰 레코드를 찾는데 시간이 많이 걸리지만, ㅗ치종 레코드를 찾는 데까지는 시간이 많이 걸리지 않음
      - 네스티드 루프 조인은 최고 응답속도 전략에 적합하다는 것을 할 수 있고
      - 해시 조인 쿼리는 최고 스루풋 전략에 유리
  20. 인덱스 정렬 선호
      - orderBy또는 Group By를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행 
2. 조인 최적화 알고리즘
   1. Exhaustive 검색 알고리즘
      - from절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법
      - 시간 많이 걸림
   2. Greedy 검색 알고리즘
      - 실행할떄마다 최소 선택, 
      - 맞는 값은 나중에
# 4. 쿼리힌트
1. 인덱스 힌트
   1. Straight_join
      - 조인 순서를 고정하는 역할
   2. Use index/ force index/ ignore index
      - 인덱스 사용을 직접 제어
   3. sql_calc_found_rows
      - limit에 정해져있는 수보다 더 많은 탐색 진행
      - 개발자의 편의를 위한 인덱스
2. 옵티마이저 힌트
   1. 옵티마이저 힌트의 영향범위
      - 인덱스
      - 테이블
      - 쿼리블록
      - 글로벌
   2. MAX_EXECUTION_TIME
      - 쿼리의 실행 시간
   3. SET_VAR
      - 쿼리의 조인 버퍼나 optimizer_switch같이 시스템 변수를 제어
   3. SEMIJOIN & NO_SEMIJOIN
      - 세미 조인에서 어떤 세부 전략을 사용할지
   4. SUBQUERY
      - 세미 조인 최적화를 사용할 수 없을떄 사용
   5. BNL & NO_BNL & HASHJOIN & NO_HASHJOIN
      - 해시 조인을 유도 하거나 해시 조인을 사용하지 않게 하려고 사용
   6. JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX
      - Straght 조인에서는 일부는 조인 순서를 강제하고, 나머지는 옵티마이저에게 순서를 결정하게 맞기는 것이 불가능
      - 이 단점을 보안하기 위해 사용
   7. MERGE & NO_MERGE
      - 가능한한 임시테이블을 사용하지 않도록 또는 임시 테이블을 사용하도록 튜닝
   8. INDEX_MERGE & NO_INDEX_MERGE
      - 인덱스 머지 : 여러 인덱스를 통해 검색된 레코드로부터 교집합 또는 합집합만을 구해서 결과를 반환
      - 위를 사용할지 말지
   9. NO_ICP
      - 인덱스 컨디션 푸시다운 사용할지말지
   10. SKIP_SCAN & NO_SKIP_SCAN
       - 인덱스의 선행 칼럼에 대한 조건 없이도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 매우 훌륭한 최적화 기능
   11. INDEX & NO_INDEX
       - 인덱스 힌트를 대체하는 용도