정렬, 집합의 explain의 경우

# 단원정리
## 1. 개요
### 1. 쿼리 실행 절차
- 1. 파싱, 2. 인덱스 선택 -> 실행계획 3. 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
### 2. 옵티마이저의 종류
- 비용기반 최적화
  - 쿼리 처리를 위한 여러가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
- 규칙 기반 최적화
  - 옵티마이저에 내장된 우선 순위에 따라 실행계획
## 2. 기본 데이터 처리
### 1. 풀 테이블스캔과 풀 인덱스 스캔
1. 풀테이블 스캔
   - 테이블의 레코드 건수가 너무 작은 경우
   - 레인지 스캔을 하더라도, 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
2. 풀테이블 스캔은 디스크로부터 페이지를 하나씩 읽어오지 않는다
   - 몇개를 포그라운드 스레드로 읽다가, 특정 시점부터는 읽기 작업을 백그라운드 쓰레드로 넘긴다.
   - 이렇게 미리 버퍼풀에 준비된 데이터를 가져다 사용하기만 하면 됨
   - innodb_read_ahead_threshold 시스템 변수에 설정 된 개수만큼의 연속된 페이지가 읽히면, 백그라운드 스레드로 버퍼풀로 적재
- Count()로는 풀인덱스 스캔가능, 레코드 수만 찾으면 되니깐. 다만 *로 하면 다른 칼럼 정보가 필요해서 풀테이블 스캔
### 2. 병렬처리
- 하나의 쿼리를 최대 몇개의 스레드로 가져오게 할 것인지
- 현재는 select쿼리에서면 병렬처리 가능, 스레드 수가 CPU 코어개수를 넘어서면 성능이 오히려 떨어질 수 있음
### 3. ORDER BY 처리(Using filesort)
- 인덱스 이용   
- Filesort이용 
  - 정렬 기준이 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과르 정렬해야하는 경우
  - Union의 겨로가 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
  - 랜덤하게 결과 레코드를 가져와야 하는 경우
- 인덱스를 이용하지 않고 별도의 정렬처리를 수행했는지는 Using filesort 메세지가 표시되는지 여부로 판단
1. 소트버퍼
   - 정렬을 수행하기 위한 별도의 메모리 공간
   - 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공강보다 크면, 레코드를 여러 조각으로 나눠서 정렬을 수행하고 그 결과를 임시로 디스크에 기록
   - 그 다음에 레코드를 가져와서 다시 정렬하면서 반복적으로 디스크에 임시 저장 -> 병합 정렬 필요
   - 다만, 버퍼 사이즈가 크면, 리눅스 계열에서는 큰 메모리 공간 할당 떄문에 성능이 떨어질 수도 있다.
   - 소트 버퍼는 세션 메모리 영역에 해당되며, 여러 클라이언트가 공유할 수 없다. 그래서 여러커넥션에서 동시에 정렬이 실행되면 oom 문제 발생가능한데, 
     - oom은 메모리를 가장 많이 먹는 프로세스르 강제 종료하기 떄문에 일반적으로 메모리를 가장 많이 사용하는 MySQL 서버가 강제 종료 1순위가 된다. 
2. 정렬 알고리즘
   1. 싱글 패스 
      - Select 대상이 되는 칼럼 전부를 담아서 정렬을 수행
   2. 투패스
      - 정렬 대상이 되는 데이터만 먼저 읽고 정렬 후, 다른 데이터를 테이블에서 다시 조회한다
   3. 정렬 처리 방법
      - 인덱스를 이용한 정렬
        - 인덱스에 있는 정보를 그대로 가져옴
        - 해시 인덱스나 전문 검색 인덱스에는 사용 불가, 조인이 있는 경우 네스티드-루프 방식을 조인에서만 사용가능
          - 조인이 네스티드-루프 방식의 조인이기 떄문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.
        - 다만, 실행계획에 조인 버퍼가 있으면 순서가 흐트러질 수 있다.
      - 조인에서 드라이빙 테이블만 정렬(Using filesort)
        - 조인을 실행하기전에 첫번 쨰 테이블 레코드를 먼저 정렬한 다음 조인을 실행
      - 조인에서 조인 결과를 임시 테이블을 이용한 정렬(Using temporary; Using filesort)
        - 조인의 드라이빙 테이블이 아니라, 드리븐 테이블에 정렬 포인드가 있을떄
        - 조인된 결과를 임시 테이블로 저장 후 정렬
   4. 정렬처리 방법의 성능 비교(인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동하는지)
      - 스트리밍 방식
        - 레코드가 검색될때마다 바로바로 전송
      - 버퍼링 방식
        - orderBy, GroupBy에서는 쿼리의 결과가 스트리밍 되는 것이 불가
        - 이떄 클라이언트가 기다려야되서 버퍼링
      - 인덱스를 사용한 정렬을 제외하고 다 버퍼링 방식
      - 가능하다면, 인덱스를 사용한 정렬로 유도하고, 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하기
   5. 정렬 관련 상태 변수
      - merge 몇번했는지, 레인지 스캔 몇번했는지 알수 있다.
### 4. GROUP By 처리
- 인덱스만 사용하는 건 불가 -> 집계한다음 결과 반환해야되서
- 인덱스를 이용할떄는 인덱스를 차례대로 읽는 인덱스 스캔방법
- 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔
- 인덱스를 사용하지 못하면 임시테이블 사용
1. 인덱스 스캔을 이용하는 GroupBy
   - 조인 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할떄
   - Using index for group-by, using temporary, Using filesort가 표시되지 않는다
2. 루스 인덱스 스캔을 이용하는 Group By
   - 인덱스 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미
   - 단일 테이블 에서만 사용가능
   - (emp_no, from_date) 인덱스에서 루스 인덱스 스캔을 어떻게 하는지 예제가 나옴
3. 임시 테이블을 사용하는 Group By
   - 인덱스를 전혀 사용할 수 없을떄 사용
   - Using temporary 라는 메세지가 표시
### 5. DISTINCT 처리
- 집합함수르 사용하는 경우랑 그렇지 않은 경우, 
- 집합함수랑 같이 distinct를 사용하면 임시 테이블을 사용하나, Using temporary 메세지가 띄지 않음
1. Select DISTINCT...
   - DISTINCT를 사용할떄는 레코드(튜플)을 유니크하게 하는 것이지, 특정 칼럼만 유니크하게 조회하는 것이 아니다.
   - (first_name), last_name -> (first_name, last_name)으로 괄호는 의미가 없다.
2. 집합 함수와 함께 사용된 DISTINCT
   - 인덱스가 있으면 인덱스로 처리가능, distinct+집계함수면 임시테이블 사용
### 6. 내부 임시 테이블 활용
- 정렬하거나 그루핑할떄 사용, 다른 세션이나 다른 쿼리에서 볼 수도 없음
1. 메모리 임시테이블과 디스크 임시 테이블
   - 메모리는 TempTable이라는 스토리지 엔진, 디스크에 저장되는 테이블은 InnoDB 스토리지 엔진을 사용하도록 개선
   - 메모리의 임시테이블이 1기가 이상으로 커저서 디스크로 기록을 해야할떄는 아래 두가지 방식이 있음
     - MMAP 파일로 디스크에 기록 
     - InnoDB 테이블로 기록
2. 임시 테이블이 필요한 쿼리
   1. ORDER와 Group By에 병시된 칼럼이 다른 쿼리
   2. ORDER By나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫번쨰 테이블이 아닌 쿼리
   3. DISTINCT와 ORDER BY갇 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
   4. Union이나 Union Distict가 사용된 쿼리(select_type 칼럼이 union result인 경우)
   5. 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리
3. 임시 테이블이 디스크에 생성 되는 경우
   - 길이가 512 바이트 이상인 크기의 카럼이 있는 경우
4. 임시 테이블 관련 상태 변수
   - 이런게 있다.
## 3. 고급 최적화
- 조인 관련된 옵션과 옵티마이저 스위치 옵션이 있음
1. 옵티마이저 스위치옵션(다음주에 이어서 진행)
- MRR과 배치 키 엑세스
- 블록 네스티드 루프 조인
- 인덱스 컨디션 푸시다운(index_condition_pushdown)
- 인덱스 확장(use_index_extensions)
- 인덱스 머지(index_merge)
- 인덱스 머지-교집합(index_merge_intersection)
- 인덱스 머지-합집합(index_merge_union)
- 인덱스 머지-정렬 후 합집합(index_merge_sort_union)
- 세미 조인(semijoin)
- 테이블 폴-아웃(Table Pull-out)
- 퍼스트 매치(firstmatch)
- 루스 스캔(loosescan)
- 구체화(Materialization)
- 중복제거(Duplicated Weed-out)
- 컨디션 팬아웃(condition_fanout_filter)
- 파생 테이블 머지(derived_merge)
- 인비저블 인덱스
- 스킵 스캔
- 해시 조인
- 인덱스 정렬 선호
2. 조인 최적화 알고리즘
# 4. 쿼리힌트