# 문제
1.	풀 테이블 스캔은 항상 디스크에서 페이지를 하나씩 동기적으로 읽는다.
2.	소트버퍼는 용량 떄문에 여러 클라이언트들이 공유해서 사용한다
3.	인덱스를 사용하지 못해 별도 정렬을 수행하면 실행계획에 Using filesort가 표시된다.
4.	조인에서 “인덱스를 이용한 정렬”은 해시 인덱스나 전문 검색 인덱스에도 적용된다.
5.	GROUP BY는 항상 인덱스만으로 처리할 수 있다.
6.	정렬 알고리즘에서 정렬 처리방법은 인덱스를 이용한 정렬, 조인에서 드라이빙 테이블만 정렬, 조인에서 조인 결과를 임시 테이블을 이용한 정렬이 있다.
7.	풀 테이블 스캔 중 연속 페이지가 innodb_read_ahead_threshold만큼 읽히면 ( ______ ) 스레드가 버퍼 풀로 적재한다.
8.	소트 버퍼보다 정렬 대상이 크면 조각 정렬 후 디스크에 임시 저장하고 추후에 조각끼리 ( ______ ) 정렬을 수행한다.
9.	루스 인덱스 스캔 기반 GROUP BY는 ( ______ ) 테이블에서만 사용 가능하다.
10.	임시 테이블이 디스크에 생성되는 조건 중 하나: 길이가 ( ______ ) 이상인 칼럼이 있는 경우.


# 답지
1.	X
2.	X
3.	O
4.	X
5.	X
6.	O
7.	백그라운드
8.	병합(머지)
9.	단일
10.	512 바이트

--- 
1.	ORDER BY에서 인덱스를 쓰지 않으면 Using filesort가 EXPLAIN에 표시된다.
2.	소트 버퍼(sort buffer)는 세션마다 따로 할당되며 여러 커넥션이 공유한다.
3.	정렬의 싱글 패스 방식은 “정렬 키만 먼저 모아서 정렬한 뒤, 나머지 컬럼은 나중에 테이블에서 다시 읽는다.”
4.	루스 인덱스 스캔은 단일 테이블에서만 가능하다.
5.	DISTINCT가 집계 함수와 함께 쓰이면 내부 임시 테이블을 사용할 수 있지만 EXPLAIN에 Using temporary가 안 뜰 수 있다.
6.	조인에서 조인 버퍼(블록 NLJ 등)를 쓰면 드라이빙 테이블의 읽기 순서(정렬 순서)가 흐트러질 수 있다.
7.  ORDER BY와 GROUP BY에 명시된 칼럼 구성이 서로 다르면 보통 내부 ________ 테이블이 필요하다.
8.	정렬의 투 패스(two-pass) 방식은 ________(들)만 먼저 모아 정렬하고  이후 ________을(를) 테이블에서 다시 조회한다.
9.	내부 임시 테이블은 메모리에서는 ________ 스토리지 엔진을, 디스크에서는 ________ 스토리지 엔진을 사용하도록 개선되었다.
10.	인덱스 머지 – 정렬 후 합집합(sort-union)을 사용하는 경우는 조건에 맞는 결과물들이 반드시 pk 순서대로 정렬이 되어 있어야한다.

1.	O
2.	X  
3.	X  
4.	O
5.	O
6.	O
7.	임시(temporary)
8.	정렬 키, 나머지 컬럼(데이터)
9.	TempTable, InnoDB
10. X