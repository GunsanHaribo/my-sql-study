
# 쿼리 실행 절차
1. SQL 파싱(Parsing)
	- SQL 서버의 SQL 파서 모듈로 처리, 파스 트리가 만들어짐
	- 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리) 한다
2. 최적화 및 실행계획 수립
	- SQL 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을 지 선택함
	- 불필요한 조건 제거 및 연산 단순화
	- 여러 테이블의 조인이 있는 경우, 어떤 순서로 테이블 읽을 지 결정
	- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
	- 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는 지 결정
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
	- 스토리지 엔진에 레코드를 읽어오도록 요청하고 MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나, 정렬하는 작업 수행

# 옵티마이저 종류

### 비용 기반 최적화(Cost-based optimizer, CBO)
- 현재 대부분의 DBMS 채용
- 쿼리 처리를 위한 여러 방법을 만들고, 각 단위 작업 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출함

### 규칙 기반 최적화(Rule-based optimizer, RBO)
- 초기버전 오라클 DBMS에서 많이 사용
- 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행계획 수립

# 기본 데이터 처리
- 옵티마이저 결정에 따라 데이터 읽고 가능하는 방식

## 풀 테이블 스캔과 풀 인덱스 스캔

### **풀 테이블 스캔**
- 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업 처리

**사용되는 경우**
- 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

InnoDB 스토리지 엔진에서 특정 테이블의 연속된 데이터 페이지가 읽히면
백그라운드 스레드에 의해 리드 어헤드 작업 자동 시작됨

### 리드 어헤드
- 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청 오기 전 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 적재하는 기능
- 풀 테이블 스캔 실행 시, 첫 몇 페이지는 포그라운드 스레드가 읽음
	- 이후 특정 시점부터는 읽기 작업을 백그라운드 스레드가 읽음
	- 읽기를 넘겨 받는 시점부터는 한 번에 4~64개씩 페이지를 읽으면서 쿼리가 상당히 빨라짐


### 병렬 처리
- 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리
- 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어듬
-  서버에 장착된 CPU 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있음

## ORDER BY 처리
정렬을 처리하는 두 가지 주요 방법들

### 1. 인덱스를 이용하는 방법

장점
- INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.

단점
- INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 
- 인덱스 때문에 디스크 공간이 더 많이 필요하다. 
- 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.

#### 2. Filesort 이용
장점
- 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다. 
- 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.

단점
- 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다

#### 인덱스 정렬 튜닝이 어려운 이유
- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY, DISTINCT의 결과를 정렬해야 하는 경우
- UNION와 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

### Sort버퍼
- 정렬을 수행하기 위해서 별도로 할당받아서 사용하는 메모리 공간
- 세션 메모리 영역에 존재
	- 커넥션이 많으면 많을수록, 정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미
- 정렬이 필요한 경우에만 할당
- 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가
- 정렬 대상이 Sort버퍼보다 클 경우
	1. 레코드를 여러 조각으로 나눔
	2. 메모리의 Sort 버퍼에서 각 조각을 정렬 후 임시로 디스크에 저장
	3. 디스크에 저장된 정렬된 조각들을 다시 병합(Multi-merge)하면서 최종 정렬을 수행
	4. 이 과정에서 디스크 I/O가 발생하여 성능이 저하

## 정렬 방식 (Sort 버퍼 사용 방식)
**싱글 패스 정렬 방식**: 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 방식, 버퍼 공간을 많이 사용함

**투 패스 정렬 방식**: 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식, 테이블을 두 번 읽어야 함

## 정렬 처리 방법(실행 계획)
### **인덱스를 시용하는 정렬**
- 별도 표기 없음
- 가장 빠름
- 조건
	- ORDER BY 칼럼이 첫 번째 읽는 테이블에 속해야 하며, 순서대로 인덱스가 생성되어 있어야 함

### 조인의 드라이빙 테이블만 정렬
- Using filesort 메시지 표시(버퍼링 방식)
- 조인을 실행하기 전, 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행함
	첫 번째로 읽히는 테이블 칼럼만 ORDER BY 절을 작성해야 함

### 임시 테이블을 이용한 정렬
- Using temporary; Using filesort 메시지 표시
- 가장 느리고 버퍼링 방식을 사용함
- 조인의 드라이빙 테이블만 정렬을 제외한 나머지 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거침

## 쿼리가 처리되는 방법
### 스트리밍 처리
- 서버 쪽에서 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
- 쿼리 요청하고 곧바로 원했던 첫 번째 레코드 전달 받음 = 빠르게 데이터 가공 작업 시작 가능함
- 웹 서비스 같은 OLTP 환경에서 적합함
- 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있음
	- 풀 테이블 스캔 결과가 아무런 버퍼링 처리나 필터링 과정 없이 바로 클라이언트로 스트리밍 되기 때문
- ORDER BY나 GROUP BY 같은 처리는 쿼리 결과가 스트리밍 되는 것을 불가능하게 만듬
- 인덱스를 이용한 정렬 방식이 스트리밍 처리 방식에 속함

### 버퍼링 방식
- 먼저 결과를 모아서 MySQL 서버에서 일괄 가공하는 방식
- LIMIT 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않음
- 조인의 드라이빙 테이블만 정렬하는 방식, 임시 테이블을 이용한 정렬 방식이 버퍼링 방식에 속함


## GROUP BY 처리
HAVING 절
- GROUP BY 결과에 대해 필터링 역할 수행

## 인덱스를 이용한 스캔 방식
### 타이트 인덱스 스캔
- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그룹핑할 때, GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그룹핑 작업 수행하고, 그 결과로 조인을 처리함
- GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것 = 쿼리 실행 시점에 추가 정렬 작업이나 내부 임시 테이블 필요하지 않음
- 유니크한 값의 수가 많을수록 성능 향상

### 루스 인덱스 스캔
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 방식
- 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용 가능함
- 프리픽스 인덱스(Prefix Index)는 루스 인덱스 스캔 사용할 수 없음
- 유니크한 값의 수가 적을수록 성능 향상
	- 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어 냄

### 인덱스를 사용하지 못하는 경우
- 내부적으로 GROUP BY 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행함

## DISTINCT 처리
- GROUP BY와 동일한 방식으로 처리
	- GROUP BY를 수행하는 쿼리에 ORDER BY절이 없으면 정렬 수행 X
- SELECT 하는 레코드(튜플)을 유니크하게 SELECT 하는 것
	- 특정 칼럼만 유니크하게 조회하는 것 X
	- ex) SELECT DISTINCT first_name, last_name FROM employees;
		== (first_name, last_name) 조합 전체가 유니크한 레코드를 가져옴
- MySQL 서버는 `DISTINCT` 뒤의 괄호 `()`는 의미 없이 제거
- **집합 함수와 함께 사용된 DISTINCT:**
	- `COUNT(col1)`: `col1`의 전체 개수
	- `COUNT(DISTINCT col1)`: `col1`의 유니크한 값의 개수

## 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑할 때는 내부적인 임시 테이블을 사용함
	- 임시 테이블 != 내부적인 임시 테이블
- MySQL 엔진이 사용하는 임시테이블 = 처음에는 메모리에 생성됐다가 크기가 커지면 디스크로 옮겨짐
- 내부적인 임시테이블은 쿼리 처리가 완료되면 자동 삭제

### 메모리 임시 테이블과 디스크 임시 테이블
- MySQL 8.0 기준
	- 메모리: TempTable이라는 스토리지 엔진 사용(가변 길이 타입 지원)
	- 디스크: InnoDB 스토리지 엔진 사용(트랜잭션 지원)
- 메모리 임시 테이블의 최대 크기(`temptable_max_ram`, 기본값 1GB)를 초과하면 디스크로 전환
- 디스크 전환 시 `MMAP` 파일을 사용하거나 `InnoDB` 테이블로 기록. (MMAP이 오버헤드가 더 적음)

### 임시 테이블이 필요한 쿼리
- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우
- DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리
- 쿼리 실행 계획에서 select_type이 DERIVED인 쿼리

### 임시 테이블이 디스크에 생성되는 경우
- UNION이나 UNION ALL에서 SELECT 되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블 크기가 tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나temptable_max_ram 시스템 변수 값보다 큰 경우


# 고급 최적화
MySQL 서버 옵티마이저가 실행계획 수립할 때
1. 통계정보
2. 옵티마이저 옵션
두 개를 결합해서 최적의 실행 계획을 수립하게 됨

옵티마이저 옵션은
1. 조인 관련된 옵티마이저 옵션
2. 옵티마이저 스위치
로 구분할 수 있음
















