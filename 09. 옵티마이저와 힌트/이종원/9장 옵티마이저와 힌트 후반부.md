## 옵티마이저 스위치 옵션
### MRR과 배치 키 액세스(mrr & batched_key_access)
MRR 
- Multi Range- Read를 줄여서 부르는 이름
- 네스티드 루프 조인의 단점을 보안하기 위해 조인 대상 테이블 중 하나로부터 레코드를 읽어서 조인 버퍼에 버퍼링하는 방식
	- 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링하는 것

네스티드 루프 조인
- 드라이빙 테이블(조인에서 제일 먼저 읽는 테이블)의 레코드를 한 건 읽어서 드리븐 테이블(조인되는 테이블에서 드라이빙이 아닌 테이블들)의 일치하는 레코드를 찾아서 조인을 수행하는 것
- MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인

### 블록 네스티드 루프 조인
- 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식
- 조인용 별도 버퍼가 사용됨

### 조인 버퍼
- 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리하는데 이때 사용되는 메모리 캐시를 조인 버퍼라고 함

### 인덱스 컨디션 푸시다운(ICP)
- 불필요한 데이터 조회를 피하기 위해 WHERE 조건 절의 일부를 스토리지 엔진 레벨에서 미리 처리하도록 작업을 떠넘기는 것
- 원래 인덱스를 비교하는 작업은 MySQL 엔진이 수행하는 작업
	- MySQL 5.5버전까지는 인덱스를 범위 제한 조건으로 사용하지 못하면 스토리지 엔진으로 전달하지 않았음
	- 5.6 버전부터는 인덱스를 범위 제한 조건으로 사용 못하더라도 인덱스에 포함된 칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달할 수 있게 개선됨

### 인덱스 확장
- InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할 지를 결정하는 옵션
- 세컨더리 인덱스에 프라이머리 키가 포함되어 있으므로 정렬 작업 역시 인덱스를 활용해서 처리되는 장점 존재

### 인덱스 머지
- 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리 처리함
- 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때, 인덱스 머지 실행 계획을 선택함

#### 세부 실행 계획
##### 인덱스 머지 - 교집합(index_merge_intersection)
- 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환
- 옵티마이저가 각각의 조건에 일치하는 레코드 건수를 예측해 본 결과, 두 조건 모두 상대적으로 많은 레코드를 가져와야 할 경우에 처리됨

##### 인덱스 머지 - 합집합(index_merge_union)
- WHERE 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 OR 연산자로 연결된 경우에 사용되는 최적화
- ex) WHERE first_name = "LEE" OR hire_date ='1987-03-31'
- UNION 알고리즘을 통해서 병합 = 두 결과 집합을 정렬해서 중복 레코드를 제거함
	- 인덱스 검색을 통한 두 결과 집합이 모두 프라이머리 키로 정렬되어 있으면 두 집합에서 하나씩 가져와서 서로 비교하면서 중복된 레코드들을 제거할 수 있음

##### 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
- 인덱스 머지 작업을 하는 도중에 결과 정렬이 필요할 경우 Sort union 알고리즘 사용함
- 각 집합을 특정 칼럼에 대해 정렬한 다음 중복 제거를 수행함

### 세미 조인(semijoin)
- 실제 조인을 수행하지 않고, 다른 테이블에서 조건에 일치하는 레코드 유무만 체크하는 형태의 쿼리
- ex) SELECT * FROM 테이블 WHERE 칼럼 IN (SELECT 문)
	- MySQL에서는 세미조인 최적화 기능이 없을 때, 테이블을 풀 스캔한 다음, 하나씩 서브 쿼리 조건에 일치하는 지 비교함
- "=(서브쿼리)", "IN(서브 쿼리)" 형태의 세미 조인 쿼리는 3가지 최적화 방법 적용 가능함
	- 세미 조인 최적화
	- IN-to-EXISTS 최적화
	- MATERIALIZATION 최적화
- "<>(서브쿼리)", "NOT IN(서브 쿼리)" 형태의 안티 세미 조인 쿼리는 2가지 최적화 방법 적용 가능함
	- IN-to-EXISTS 최적화
	- MATERIALIZATION 최적화
- MySQL 8.0 버전부터의 최적화 전략
	- 테이블 풀아웃(Table Pull-out) : 사용 가능하면 세미조인보다 좋은 성능 제공
	- 중복 제거(Duplicate Weed-out)
	- 퍼스트 매치(First Match)
	- 루스 스캔(Loose Scan)
	- 구체화(Materialization)

#### 테이블 풀아웃(Table Pull-out)
- 세미조인의 서브쿼리에 사용된 테이블을 외부 쿼리로 끄집어낸 후, 쿼리를 조인 쿼리로 재작성하는 형태의 최적화
	- 서브 쿼리 최적화가 도입되기 이전 수동으로 쿼리를 튜닝하던 대표적인 방법
- 별도로 Extar 컬럼에 Using table pullout 문구가 출력되지 않음
	- 사용 여부 판단은 실행 계획에서 해당 테이블의 id 칼럼 값이 같은지 다른지를 비교해보는 것
	- 또는 EXPLAIN 명령 실행 직후, SHOW WARNINGS 명령으로 재작성한 쿼리를 살펴보는 것
- 조건
	- 세미 조인 서브쿼리에서만 가능
	- UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능
	- 테이블 풀아웃과 다른 최적화 방법 동시 적용 가능함
	- 서브 쿼리의 모든 테이블을 외부 쿼리로 끄집어 낼 수 있다면 서브쿼리는 사라짐

#### 퍼스트 매치(First Match)
- IN (서브쿼리) 형태의 세미 조인을 EXISTS (서브쿼리) 형태로 튜닝하는 방식과 비슷
- 테이블의 레코드에 대해 서브쿼리의 테이블에 일치하는 레코드 1건만 찾으면 더이상 서브 쿼리 테이블 검색을 하지 않는 방식
- 제한 사항
	- 하나의 레코드만 검색되면 더이상 검색을 멈추는 단축 실행 경로이기 때문에 해당 최적화에서는 서브쿼리가 참조하는 모든 외부 테이블을 먼저 조회된 이후에 실행됨
	- 상관 서브 쿼리에서도 사용 가능함
	- GROUP BY 나 집합 함수가 사용된 서브쿼리의 최적화에 사용될 수 없음

#### 루스 스캔(Loose Scan)
- 루스 인덱스 스캔과 비슷한 읽기 방식 사용
	- 루스 인덱스 스캔으로 서브 쿼리 테이블을 읽고, 외부 쿼리를 드리븐으로 사용해서 조인을 수행함 = 유니크한 칼럼만 읽어서 서브쿼리를 실행
- 사용 가능한 형태의 쿼리
	- SELECT ... FROM ... WHERE 표현식 IN (SELECT keypart1 FROM tab WHERE ...)
	- SELECT ... FROM ... WHERE 표현식 IN (SELECT keypart2 FROM tab WHERE ketpart1 ='상수') 

#### 구체화(Materialization)
- 세미조인에서 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화함
- 구체화 = 내부 임시 테이블을 생성
- GROUP BY 절이 있어도 해당 최적화 전략 사용 가능함
- 조건 및 특성
	- IN(서브쿼리) 에서 서브쿼리는 상관 서브쿼리가 아니어야 함
	- 서브쿼리는 GROUP BY 나 집합 함수들이 사용돼도 구체화 사용할 수 있어야 함
	- 구체화가 사용되는 경우에는 내부 임시 테이블 사용됨

#### 중복 제거(Duplicate Weed-out)
- 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 알고리즘
- INNER JOIN과 GROUP BY 절로 바꿔서 실행하는 것과 동일한 작업으로 쿼리 처리
	- 서브 쿼리의 조건에 대해 검색 수행 후 외부 쿼리에 조인을 실행(INNER JOIN)
	- 조인된 결과를 임시 테이블에 저장
	- 저장된 결과에서 중복 제거(GROUP BY)
	- 제거 후 남은 레코드 반환
- 별도로 Duplicate Weedout 문구가 표시되거나 하지 않음
	- Start temporary와 End temporary 문구가 별도로 표기됨

### 컨디샌 팬아웃(condition_fanout_filter)
- 여러 테이블이 조인되는 경우, 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행하게 하는 최적화 방식
- 칼럼값의 분포도를 살펴보고 다른 테이블의 칼럼값을 예측함
- 컨디션 팬아웃 최적화 활성화 조건
	- WHERE 조건절에 사용된 칼럼에 대해 인덱스가 있는 경우
	- WHERE 조건절에 사용된 칼럼에 대해 히스토그램이 존재하는 경우
- 해당 기능을 활성화하면 더 정교한 계산을 거쳐서 실행계획을 수립하지만 더 많은 시간과 컴퓨팅 자원을 사용함
	- 쿼리가 간단하고 쿼리 실행 계획이 잘못된 선택을 한 적이 별로 없다면 해당 기능은 성능 향상에 크게 도움이 되지 않음

### 파생 테이블 머지(derived_merge)
- 파생 테이블(Derived Table)이란?
	- FROM 절에 사용된 서브쿼리(SELECT .. FROM (SELECT 절))
- MySQL 내부적으로 임시 테이블을 생성하고 FROM절 내부의 데이터를 읽어서 임시 테이블에 집어넣음. 그 뒤 검색을 시작
- MySQL 5.7버전부터 파생 테이블로 만들어진 서브쿼리를 외부 쿼리와 병합해서 서브 쿼리 부분을 제거하는 최적화 도입 = 파생 테이블 머지 옵션
- 아래 조건으로 서브쿼리가 사용되면 외부 쿼리로 수동 병합해서 작성하면 성능상 좋음
	- 집계 함수와 윈도우 함수
	- DISTINCT
	- GROUP BY HAVING
	- LIMIT
	- UNION, UNION ALL
	- SELECT 절
	- 값이 변경되는 사용자 변수가 사용

### 인비저블 인덱스
- 인덱스를 삭제하지 않고 해당 인덱스를 사용하지 못하게 제어하는 기능
- ALTER TABLE ... ALTER INDEX ... \[VISIBLE | INVISIBLE] 명령

### 스킵 스캔
- 인덱스 핵심 = 값 정렬
- 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로 인덱스를 이용할 수 있는 방법
	- (A,B) 칼럼으로 구성된 인덱스가 있을 때, A 칼럼 인덱스를 스킵하고 B 인덱스를 이용할 수 있는 방법
- 조건
	- WHERE 조건절에 B 칼럼에 대한 비교 조건 필수
	- 소수의 유니크한 값을 가질 때만 사용 가능

### 해시 조인(hash_join)
- 첫 번째 레코드를 찾는 데 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않음(최고 스루풋 전략 적합) => 분석에 적합
	- 네스티드 루프 조인은 마지막 레코드를 찾는 데까지는 시간이 많이 걸리지만 첫 번째 레코드를 찾는 것은 상대적으로 훨씬 빠름(최고 응답속도 전략 적합) => 온라인 서비스에 적합
- MySQL은 범용 DBMS로 대용량 데이터 분석용으로는 적합하지 않음
- 조인 조건의 칼럼이 인덱스가 없다거나 조인 대상 테이블 중 일부의 레코드 건수가 매우 적은 경우 등에 대해서만 해시 조인 알고리즘을 사용함

#### 해시 조인 단계
1. 빌드 단계(Build - phase)
	- 조인 대상 테이블 중에서 레코드 건수가 적어서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성하는 작업 수행
	- 해시 테이블을 만들 때 사용되는 원본 테이블 = 빌드 테이블
2. 프로브 단계(Probe-phase)
	- 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 과정
	- 읽는 나머지 테이블 = 프로브 테이블

### 인덱스 정렬 선호(prefer_ordering_index)
- ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한 경우, 쿼리의 실행 계획에서 인덱스의 가중치를 높이 설정해서 실행됨

## 조인 최적화 알고리즘
### Exhaustive 검색 알고리즘
- FROM 절에 명시된 모든 테이블 조합에 대해 실행 계획 비용을 계산해서 최적 조합 1개를 찾는 방법
- 테이블이 20개라면 20!(Factorial)개가 됨

### Greedy 검색 알고리즘
1. 전체 N개 테이블 중에서 정의된 개수의 테이블 조합을 생성, 
2. 정의된 개수의 테이블 조합에서 최소 비용 실행 계획을 하나 선정
3. 최소 비용 실행 계획의 첫 번째 테이블을 부분 실행 계획의 첫 테이블로 선정
4. 전체 N-1개의 테이블 중에서 3번에서 선택된 테이블 제외, 다시 정의된 개수의 테이블로 가능한 조인 조합 생성
5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 부분 실행 계획에 대입하면서 실행 비용 계산
6. 5번의 비용 계산 결과, 최적 실행 계회에서 두 번째 테이블을 3번에서 생성된 부분 실행 계획의 두 번째 테이블로 선정
7. 남은 테이블이 모두 없어질 때까지 4~6번 과정 반복 실행하면서 부분 실행 계획에 테이블의 조인 순서 기록
8. 최종적으로 부분 실행 계획의 테이블의 조인 순서 결정


# 쿼리 힌트
- 옵티마이저에게 쿼리 실행 계획을 어떻게 수립해야할 지 알려줄 수 있는 방법을 만드는 것

## 인덱스 힌트



## 옵티마이저 힌트






---
InnoDB 스토리지 엔진은 프라이머리 키를 클러스터링 키로 생성함

모든 세컨더리 인덱스 = 리프 노드에 프라이머리 키 값을 가짐

인덱스를 이용한 쿼리 실행 시, 대부분 옵티마이저는 테이블 당 하나의 인덱스에 대해 실행 계획을 수립함

쿼리에 한 테이블에 대한 WHERE 조건이 여러 개 있더라도 하나의 인덱스에 포함된 칼럼에 대한 조건만으로 인덱스를 검색, 나머지 조건은 읽어온 레코드에 대해서 체크하는 형태로 사용됨

조인 실행 시 테이블 순서 = 쿼리 성능 매우 큰 영향 미침