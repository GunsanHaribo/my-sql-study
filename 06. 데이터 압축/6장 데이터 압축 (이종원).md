# 페이지 압축(Transparent Page Compression, 투명 페이지 압축)
- MySQL 서버가 디스크에 저장하는 시점에 데이터 페이지가 압축되어 저장됨
- MySQL 서버가 디스크에서 데이터 페이지를 읽어올 때 압축이 해제됨
	- 버퍼 풀에 데이터 페이지가 한 번 적재되면 InnoDB 스토리지 엔진은 압축이 해제된 상태로만 데이터 페이지 관리함
- 운영체제별로 특정 버전의 파일 시스템에섬나 지원되는 펀치 홀(Punch hole) 기능 사용
	- 만약 16KB 데이터 페이지에 대해 쓰기 작업을 진행하면 16KB 중에 압축한 데이터 7KB와 빈 공간 9KB와 함께 디스크에 쓰기 작업을 진행함
- 실제 페이지 압축은 많이 사용되지 않음
	- Why?
		- 운영체제 뿐만 아니라 하드웨어 자체에서도 펀치 홀 기능을 지원해야 사용 가능
		- 파일 시스템 관련 명령어(유틸리티)가 펀치 홀을 지원하지 못함
- 페이지 압축을 이용하려면 COMPRESSION 옵션을 설정하면 됨
```SQL
CREATE TABLE 테이블명(레코드명 타입) COMPRESSION = "zlib";
```


# 테이블 압축
- 운영체제, 하드웨어 제약 없이 사용 가능함
- 단점
	1. 버퍼 풀 공간 활용률 낮음
	2. 쿼리 처리 성능 낮음
	3. 빈번한 데이터 변경 시 압축률 떨어짐

## 압축 테이블 생성
- 원본 데이터 페이지의 압축 결과가 목표 크기보다 작거나 같을 때 까지 반복해서 페이지를 스플릿 진행함
- zlib를 이용해 압축을 실행함
	- 많은 CPU 자원 소모함
- 압축을 사용하려는 테이블의 별도 테이블 스페이스 사용해야함
	- innodb_file_per_table 시스템 변수가 ON 설정된 상태에서 테이블 생성되어야 함
	- 테이블을 생성할 때 ROW_FORMAT = COMPRESSED 옵션을 명시해야함
	```SQL
	SET GLOBAL innodb_file_per_table = ON;
	
	CREATE TABLE 테이블명(레코드명 타입) 
		ROW_FORMAT = COMPRESSED
		KEY_BLOCK_SIZE = 숫자(KB 단위);
	```

- FILE_BLOCK_SIZE = 압축된 페이지가 저장될 페이지 크기 지정

### 압축 방법 예시
조건 : 16KB 데이터 페이지 압축, KEY_BLOCK_SIZE = 8

16KB 데이터 페이지를 압축 진행함
1. 압축된 결과가 8KB 이하면 그대로 디스크에 저장(압축 완료)
2. 압축된 결과가 8KB 초과하면 원본 페이지를 스플릿(split, 나누기)해서 2개의 페이지에 8KB씩 저장하고 다시 나뉜 페이지 각각에 대해 압축을 진행함


### KEY_BLOCK_SIZE 결정
- 샘플 데이터를 저장해보고 적절한 지 판단하고 KEY_BLOCK_SIZE를 결정함
	- 최소한 테이블 페이지가 10개 정도 생성되도록 테스트 데이터를 INSERT 해보는 것이 좋음
- 압축 실패율이 3~5% 미만으로 유지할 수 있게 KEY_BLOCK_SIZE 설정하는 것이 좋음
	- 압축 실패율이 높다고 해서 압축 사용하지 말라는 의미는 아님
	- **INSERT만 되는 로그 테이블의 경우에는 한 번 INSERT 되면 이후 다시 변경되지 않기에, 압축 실패해서 재압축하더라도 괜찮음**

## 압축된 페이지의 버퍼 풀 적재 및 사용
- InnoDB 스토리지 엔진은 압축된 테이블의 데이터 페이지를 버퍼풀에 적재하면 압축된 상태와 압축이 해제된 상태 2개 버전을 관리함
	- 디스크 읽은 상태 그대로 데이터 페이지 목록을 관리하는 LRU 리스트
	- 압축된 페이지들의 압축 해제 버전인 Unzip_LRU 리스트
- 압축 해체된 버전의 데이터 페이지를 적절한 수준으로 유지하기 위해 어댑티브(적응적인) 알고리즘 사용함
	- CPU 사용량이 높은 서버에서는 가능하면 압축과 압축 해제를 피하기 위해 Unzip_LRU 비율을 높여서 유지
	- Disk IO 사용량이 높은 서버에서는 가능하면 Unzip_LRU 리스트의 비율을 낮춰서 InnoDB 버퍼 풀의 공간을 더 확보함
- 버퍼 풀 공간이 필요한 경우에는 LRU 리스트는 원본 데이터 페이지 유지, Unzip_LRU 리스트에서 압축 해제된 버전은 제거해서 버퍼 풀 공간 확보함
- 압축된 데이터 페이지가 자주 사용되는 경우에는 Unzip_LRU 리스트에 압축 해제된 페이지를 계속 유지하면서 압축 및 압축 해제 작업을 최소화함
- 압축된 데이터 페이지가 사용되지 않아서 LRU 리스트에서 제거되는 경우에는 Unzip_LRU 리스트에서도 함께 제거됨


## 테이블 압축 관련 설정

- innodb_cmp_per_index_enabled
	- 테이블 압축이 사용된 테이블의 모든 인덱스별 압축 성공 및 압축 실행 횟수 수집하도록 설정

- innodb_compression_level
	- Zlib 압축 알고리즘의 압축률 설정정

- innodb_compression_failure_threshold_pct 와 innodb_compression_failure_threshold_pct_max
	- 테이블 단위 압축 실패율이  innodb_compression_failure_threshold_pct 보다 커지면 압축 실행 전 원본 데이터 페이지 끝에 의도적으로 일정 크기 빈 공간을 계속 붙여나가는데innodb_compression_failure_threshold_pct_max에서 설정한 크기를 넘어설 수 없음
	- innodb_compression_failure_threshold_pct_max는 % 값을 설정함 = 전체 데이터 페이지 크기 대비 패딩 공간 비율

- innodb_log_compressed_pages
	- 압축된 데이터 페이지를 Redo 로그에 기록하는 설정
		- MySQL 서버가 비정상적으로 종료될 경우, 복구 과정이 실패하지 않도록 하기 위함


# 기타
- innodb_cmp_per_index_enabled 설정 시 인덱스별 압축 실행 횟수와 성공 횟수가 기록됨
- 로그 객체를 생성할 때, 별도의 테이블을 만들어서 압축 시켜서 저장하고 또한 별도의 서비스를 운영해서 로그만 보는 서비스를 만들어야 할 듯

