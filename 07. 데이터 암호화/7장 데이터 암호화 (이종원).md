- 핀테크 서비스처럼 중요 정보를 저장하는 서비스에서 응용 프로그램에서 암호화한 데이터를 다시 DB서버에 암호화하는 이중 암호화 방법 선택하기도 함
- 응용 프로그램 암호화는 중요 정보를 가진 칼럼 단위로 암호화 수행
- DB 수준에서는 테이블 단위로 암호화 적용
# MySQL 서버의 데이터 암호화
- InnoDB 스토리지 엔진에서 I/O 레이어에서 암호화 복호화 수행
	- DB 서버와 디스크 사이 데이터 읽고 쓰기 지점에서 암호화, 복호화 수행
- TDE(Transparent Data Encryption, Data at Rest Encryption) 방식 채택
	- 사용자의 쿼리를 처리하는 과정에서 테이블의 데이터가 암호화돼 있는지 ,암호화된 테이블도 암호화 돼 있는지 식별할 필요 없는 암호화 방식
	- Data at Rest = 메모리나 네트워크 전송 단계가 아닌 디스크에 저장된 단계에서만 암호화 사용됨
- 암호화 알고리즘 = AES 256 비트
	- 테이블스페이스 키는 AES-256 ECB(Electronic Code Book) 알고리즘 이용해서 암호화
	- 실제 데이터 파일은 AES-256 CBC(Cipher Block Chaining) 알고리즘 이용해서 암호화
	

## 2단계 키 관리
- TDE에서 암호화 키는 키링(Keyring) 플러그인에 의해 관리됨
	- 커뮤니티 에디션에서는 keyring_file 플러그인만, 엔터프라이즈 에디션에서는 전체 가능
- 데이터 암호화는 마스터 키와 테이블스페이스 키(프라이빗 키), 두 가지 종류의 키를 가지고 있음

마스터키 변경 쿼리문
```SQL
ALTER INSTANCE ROTATE INNODB MASTER KEY
```

### 암호화 방식
1. 외부 키 관리 솔루션(KMS, Key Management Service) 또는 디스크 파일(keyring_file 또는 keyring_encrypted_file) 사용해서 마스터 키 가져옴
2. 암호화된 테이블 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키 발급
3. 마스터 키를 이용해 테이블스페이스 키 암호화해서 각 테이블의 데이터 파일 헤더에 저장함


## 암호화와 성능
- TDE 방식이기때문에 디스크로부터 한 번 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼 풀에 적재
- 한 번 메모리에 적재되면 암호화되지 않은 테이블과 동일한 성능 보임
- 암호화한다고 해서 InnoDB 버퍼 풀의 효율이 달라지거나 메모리 사용 효율이 떨어지는 현상 발생하지 않음
	- TED를 적용한다고 해도 데이터 파일 크기는 암호화되지 않은 테이블과 동일한 크기를 가지기 때문에
- 암호화화 압축이 동시에 적용되면 먼저 압축을 진행하고 암호화를 적용함
	- 암호화를 할 경우, 랜덤한 바이트 배열을 가지는데 이는 압축률을 떨어뜨리게 됨
	- 암호화된 테이블의 데이터 페이지는 복호화된 상태로 InnoDB 버퍼 풀에 저장되지만, 압축된 데이터 페이지는 압축 또는 압축 해제의 모든 상태로 InnoDB 버퍼 풀에 존재할 수 있음

## 암호화와 복제
- 마스터 키, 테이블 스페이스 키는 레플리카 서버로 복제되지 않음
	- 복제 멤버들의 데이터 파일은 암호하되기 전의 값이 동일하더라도 암호화된 데이터가 저장된 데이터 파일 내용은 완전히 달라짐
- 복제 소스 서버 마스터 키를 변경할 때, 변경 명령 자체는 레플리카 서버로 복제되지만 실제 소스 서버의 마스터 키 자체가 레플리카 서버로 전달되는 것은 아님
- 백업 시 TDE의 키링(Key Ring) 파일 역시 백업해야 데이터 복구가 가능해짐
	- 보안을 위해 키링 파일은 별도 보관 권장


# Keyring_file 플러그인
- TDE의 암호화 키 관리는 플러그인 방식으로 제공
- keyring_file 플러그인은 테이블스페이스 키를 암호화하기 위한 마스터 키를 디스크의 파일로 관리함
	- 마스터 키는 평문으로 디스크에 저장됨 = 외부 노출 시 암호화 무용지물

## Keyring_file 플러긘 설치 방법
1. 설정 파일에서 early-plugin-load 시스템 변수에 keyring_file 플러그인을 위한 라이브러리 명시
	- TDE 플러그인의 경우, MySQL 서버가 시작되는 단계에서 가장 빨리 초기화되어야 함
2. 마스터 키를 저장할 키링 파일의 경로를 keyring_file_data 설정에 명시
	- keyring_file_data 설정의 경로는 오직 하나의 MySQL 서버만 참조해야 함

예시)

```YAML
early-plugin-load = keyring_file.so
keyring_file_data = /very/secure/directory/tde_master.key

```

## 서버 시작/재시작 시 초기화 과정
1. 서버 시작/재시작 시 keyring_file 플러그인 초기화
	SHOW PLUGINS; 명령어로 플러그인 초기화 여부 확인 가능
2. 플러그인 초기화와 동시에 keyring_file_data 시스템 변수의 경로에 빈 파일 생성(키링 파일)
3. 데이터 암호화 기능을 사용하는 테이블을 생성하거나 마스터 로테이션을 실행하면 키링 파일의 마스터 키 초기화됨


# 암호화 방법
## 테이블 암호화 방법
```SQL
CREATE TABLE 테이블명(칼럼명 타입) ENCRYPTION = 'Y';
```

ENCRYPTION = 'Y'; 를 넣으면 디스크에 기록될 때는 데이터가 자동으로 암호화되어 저장됨
다시 디스크에서 메모리로 읽어올 때는 복호화됨

default_table_encryption 시스템 변수를 ON으로 설정하면 ENCRYPTION 옵션을 별도로 설정하지 않아도 암호화된 테이블로 생성됨


### 응용 프로그램 암호화의 경우
- 응용프로그램에서 직접 암호화해서 MySQL 서버에 저장하는 경우에는, 이미 암호화된 것인지 여부를 MySQL 서버에서 인지 못함
	- 인덱스 기능을 100% 활용하기 어려움
- 응용 프로그램 암호화와 MySQL 암호화 기능 중 선택해야하는 상황이라면 MySQL 서버의 암호화 기능 선택할 것을 권장함
	- MySQL 서버의 TDE 기능으로 암호화한다면 실행 중인 MySQL 서버에 로그인만 할 수 있다면 모든 데이터를 평문으로 확인 가능
	- 응용 프로그램 암화화는 MySQL 서버에 로그인할 수 있더라도 평문 내용을 확인할 수 없음음


## 테이블스페이스 이동 방법
- 테이블을 다른 서버로 복사해야 하는 경우 또는 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우, 테이블 스페이스 이동 기능이 레코드 덤프했다가 복구하는 방식보다 효율적이고 빠름
- TDE가 적용되면 암호화된 테이블의 경우, 원본 MySQL 서버와 목적지 MySQL 서버의 암호화 키가 다르기 때문에 하나 더 신경써야 함

```SQL
FLUSH TABLES 테이블명 FOR EXPORT;
```
- 테이블스페이스를 익스포트(Export)하는 명령어
	- 임시로 사용할 마스터 키를 발급해서 해당 테이블명.cfp 파일에 기록
	- 암호화된 테이블의 테이블스페이스 키를 기존 마스터 키로 복호화 후, 임시로 발급한 마스터 키를 이용해 다시 암호화해서 데이터 파일 헤더 부분에 저장
	- 해당 테이블의 저장되지 않은 변경 사항을 모두 디스크로 기록
	- 더이상 해당 테이블에 접근할 수 없게 잠금 걸음
	- 해당 테이블의 구조를 해당 테이블 명.cfg 파일로 기록
	- 해당 테이블명.ibd 파일과 해당 테이블명.cfg 파일을 목적지 서버로 복사함

- 익스포트 명령어로 복사가 완료되면 UNLOCK TABLES 명령을 실행해서 해당 테이블을 사용할 수있게 하면 됨

- \*.cfp 파일을 복사하려는 서버에 함께 복사해야 함
	- 없어지면 복구가 불가능해짐짐


## Undo로그 및 Redo 로그 암호화
- 메모리에 존재하는 Undo로그, Redo 로그, 복제를 위한 바이너리 로그는 평문으로 존재함
	- MySQL 8.0 버전부터는 innodb_undo_log_encrypt 시스템 변수와 innodb_redo_log_encrypt 시스템 변수를 이용해 InnoDB 스토리지 엔진의 Redo로그와 Undo 로그를 암호화된 상태로 저장할 수 있게 개선함
- Undo로그와 Redo로그는 평문으로 저장하다가 암호화가 활성화되면 그때부터 암호화해서 저장함
- 암호화된 Undo로그와 Redo로그가 암호화 비활성화하면 그때부터 저장되는 로그만 평문으로 저장
- Undo로그와 Redo로그 모두 각각의 테이블스페이스 키로 암호화됨
	- 테이블스페이스 키는 다시 마스터 키로 암호화 됨
	- 여기서 테이블스페이스 키는 실제 테이블 암호화에 사용된 테이블스페이스 키가 아닌 Undo, Redo 로그만을 위한 프라이빗 키를 의미함


## 바이너리 로그, 릴레이 로그 암호화
- 바이너리 로그는 의도적으로 상당히 긴 시간동안 보관하는 서비스이기에 암호화하는 상황에 따라 중요도 높아질 수 있음
- 바이너리 로그와 릴레이 로그 파일 암호화 기능은 디스크에 저장된 로그 파일에 대한 암호화만 담당
	- MySQL 서버 메모리 내부 또는 소스 서버와 레플리카 서버 간 네트워크 구간에서 로그 데이터 암호화하지 않음
	- 복제 멤버 간의 네트워크 구간에서도 바이너리 로그 암호화를 진행하려고 하면 MySQL 복제를 위한 계정이 SSL을 사용하도록 설정하면 됨

### 바이너리 로그, 릴레이 로그 암호화 키 관리
- 바이너리 로그와 릴레이 로그 데이터는 파일 키(File Key)로 암호화해서 디스크 저장
	- 파일 키는 바이너리 로그 암호화 키로 암호화해서 각 바이너리 로그와 릴레이 로그 파일의 헤더에 저장

#### 바이너리 로그 암호화 키 변경 방법

```SQL
ALTER INSTANCE ROTATE BINLOG MASTER KEY
```
1. 증가된 시퀸스 번호와 함께 새 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
2. 바이너리 로그 파일과 릴레이 로그 파일 스위치(새 로그 파일로 로테이션)
3. 새로 생성되는 바이너리 로그와 릴레리 로그 파일 암호화를 위해 파일 키 생성하고, 파일 키는 바이너리 로그 파일 키(마스터 키)로 암호화해서 각 로그 파일에 저장
4. 기존 바이너리 로그와 릴레리 로그 파일의 파일 키 읽어서 새 바이너리 로그짐



# 기타
- 데이터 페이지 저장은 MySQL 서버의 백그라운드 스레드가 수행함
- AES 암호화 알고리즘은 암호화하고자 하는 평문 길이가 짧은 경우, 암호화 키의 크기에 따라 암호화된 결과의 용량이 더 커질 수 있음
- 기본적으로 모든 노드는 각자의 마스터 키를 할당해야 함
	- DB서버의 로컬 디렉터리에 마스터 키를 관리하는 경우에는 소스 서버와 레플리카 서버가 다른 키를 가질 수 밖에 없겠지만 원격으로 키 관리 솔루션을 사용하는 경우에도 소스 서버와 레플리카 서버는 서로 다른 마스터 키를 갖도록 설정해야 함
- 디스크에 데이터 저장할 때, 암호화를 굳이 걸지 말고 DB의 암호화 기능을 사용하자. 그리고 정말 중요한 데이터의 경우에는 응용 프로그램으로 암호화를 걸고 다시 디스크 파일에서 암호화를 걸자.
- 로그 내용을 몰래 훔쳐봄으로써 해킹 공격 가능할 수 도 있겠군