# MVCC(Multi Version Concurrency Control)

- 멀티 버전 = 하나의 레코드에 대해 여러 개의 버전이 동시에 관리되는 것
	- UPDATE문을 작동할 경우, InnoDB 버퍼풀에는 변경된 데이터가, Undo 로그에는 변경 전의 값, 디스크 파일에는 새로운 값으로 업데이트 되었거나 되지 않은 상태, 총 2가지 버전이 존재하게 된다.
- MVCC는 격리 수준에 따라 어느 영역을 읽어올 지 결정하는 과정을 뜻함

## 잠금 없는 일관된 읽기
- MVCC는 잠금을 사용하지 않는 일관된 읽기 기능을 제공하는 것이 가장 큰 목적이다.
	- 격리 수준이 READ_UNCOMMITTED인 경우에는 변경된 데이터를 읽어서 반환
	- 격리 수준이 READ_COMMITED 혹은 그 이상인 경우에는 Undo 로그 영역의 데이터 반환
- 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업 가능함
	- SERIALIZABLE이 아니면 순수한 읽기 작업은 다른 트랜잭션 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행됨

## Undo 로그
- DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한 데이터 의미
- 트랜잭션과 격리 수준을 보장하는 데 사용된다.

### Undo 로그 모니터링
- MySQL 5.5 이전 버전에서는 한 번 증가한 Undo 로그 공간은 다시 줄어들지 않음
	- 100GB 크기의 테이블을 DELETE로 삭제하면 Undo 로그 공간에 복사되어야 함
- 트랜잭션이 오랜 시간 동안 실행될 때도 Undo 로그의 양은 급격히 증가할 수 있음
	- A, B, C 트랜잭션 중에서 B,C가 완료되었지만 가장 먼저 시작한 A 트랜잭션이 끝나지 않았으면 B, C에서 수행한 UPDATE, DELETE 실행으로 인한 Undo 로그가 존재하고 또 A 트랜잭션이 끝나지 않아서 삭제되지도 않는다.
- MySQL 8.0 버전에서는 Undo 로그를 돌아가면서 순차적으로 사용해 디스크 공간 줄이는 것 가능함, 때로는 필요 시점에서 사용 공간을 자동으로 줄여주기도 함

### Undo 테이블스페이스 관리
- Undo 로그가 저장되는 공간을 Undo 테이블스페이스라고 함
- MySQL 8.0에서부터는 항상 시스템 테이블 스페이스 외부의 별도 로그 파일에 기록되도록 개선됨
- 하나의 롤백 세그먼트는 InnoDB 페이지 크기를 16바이트로 나눈 값의 개수만큼 Undo 슬롯을 가짐
	- ex) InnoDB 페이지 크기 = 16KB -> 하나의 롤백 세그먼트 = 1024개 Undo 슬롯 가짐
- 하나의 트랜잭션이 필요로 하는 Undo 슬롯 개수 = INSERT, UPDATE, DELETE 문장 특성에 따라 최대 4개 Undo 슬롯 사용함
	- 일반적으로는 하나의 트랜잭션은 대략 2개 정도 사용함
- 최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (Undo 테이블스페이스 개수)
- 일반적인 설정 16KB InnoDB에서 기본 설정 사용 시(innodb_undo_tablespaces=2, innodb_rollback_segments=128), 대략 131,072개 트랜잭션을 동시에 처리 가능함


---

# 트랜잭션
- 작업의 완전성을 보장해주는 것 = 데이터의 정합성을 보장하기 위한 기능
	- 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT을 실행했을 경우) 아무것도 적용되지 않아야 함(오류 발생했을 경우)을 보장해주는 것
	- 부분 업데이트 현상으로 인해 실패 재처리 작업을 진행하지 않아도 됨
- 원상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 것
- InnoDB는 쿼리 중 일부라도 오류 발생 시 전체를 원 상태로 돌림 (= 트랜잭션 적용)
- MyISAM에서는 쿼리 중 일부가 오류 발생을 하더라도 부분 업데이트를 진행함
	- ex) 1이란 값을 넣은 뒤, {1, 2, 3}을 넣으면 1이 중복되어서 오류가 발생하지만 2, 3은 없어서 부분 업데이트가 진행됨

# 잠금
- 동시성을 제어하기 위한 기능
- 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨 잠금으로 나눌 수 있음
	- MySQL 엔진 잠금은 모든 스토리지 엔진에 영향을 미침
	- 스토리지 엔진 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음
- 기타 : 메타데이터 락 = 테이블 구조를 잠그는 기능, 네임드 락 = 사용자 필요에 맞게 사용할 수 있는 잠금 기능

## 종류
### 글로벌 락
- FLUSH TABLES WITH READ LOCK 명령으로 획득 가능
- 잠금 가운데 범위가 가장 큼 = MYSQL 서버 전체
	- 한 세션에서 글로벌 락을 걸면 다른 세션에서는 SELECT를 제외한 대부분의 DDL, DML 문장 실행 시, 글로벌 락 해제 전까지 대기 상태로 남음
	- 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향 미침
- 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업 받을 때 글로벌 락 사용함
#### 백업락
- InnoDB 스토리지 엔진에서는 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요 없음 - MySQL 8.0부터 Xtrabackup 이나 Enterprise Backup 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됨
- 특정 세션에서 백업락을 걸면 모든 세션에서 테이블의 스키마나 사용자 인증 관련 정보 변경할 수 없게 됨
	- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
	- REPARI TABLE과 OPTIMIZE TABLE 명령
	- 사용자 관리 및 비밀번호 변경
- 일반적인 테이블 데이터 변경은 허용됨
	- DDL 명령 실행되면 복제를 일시 중지하는 역할 수행


### 테이블락
- 개별 테이블 단위로 설정되는 잠금
- MyISAM, InnoDB 스토리지 엔진에서도 동일하게 설정 가능함
- 일반적으로 특별한 상황이 아니면 사용할 일 없음
- 명시적, 묵시적으로 특정 테이블의 락 걸 수 있음
	- 명시적
		- LOCK TABLE {table_name} \[READ | WRITE]
		- 잠금 해제(반납)은 UNLOCK TABLES 명령으로 가능함
	- 묵시적 
		- MyISAM이나 MEMORY 테이블의 데이터를 변경하는 쿼리 실행하면 발생함
			- 데이터가 변경되는 테이블에 잠금 설정하고 데이터를 변경한 후, 즉시 잠금 해제하는 형태
		- InnoDB에서는 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 단순 데이터 변경으로 묵시적 테이블 락 설정되지 않음
			- 대부분의 데이터 변경 쿼리(DML)에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침


### 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금 설정 가능함
- 단순히 사용자가 지정한 문자열(String)에 대해 잠금을 걸고 해제하는 기능
- 여러 클라이언트가 상호 동기화를 처리해야 할 때, 네임드 락을 이용하면 쉽게 해결 가능
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용 가능함
	- 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리 실행하면 한꺼번에 많은 레코드를 변경할 때, 발생하는 데드락 문제를 해결할 수 있음
```SQL
SELECT GET_LOCK('네임드락을 걸 특정 문자열', 시간(초단위))
-- 잠금 사용중이라면 초 동안만 대기하다가 자동으로 해제됨

SELECT IS_FREE_LOCK('네임드락을 걸 특정 문자열')
-- 문자열에 대해 잠금이 있는지 확인

SELECT RELEASE_LOCK('네임드락을 걸 특정 문자열')
-- 문자열에 대해 획득했던 잠금을 반납(헤제)

-- 정상적으로 락을 획득하거나 해제하면 1, 아니면 Null 또는 0 반환

```


### 메타데이터 락
- 데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경하는 경우에 자동으로 획득하는 잠금


## InnoDB 스토리지 엔진 잠금
- MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 제공하는 레코드 기반 잠금 방식
- MyISAM보다 뛰어난 동시성 처리 기능 제공함
- 이원화된 잠금 처리 탓에 MySQL 명령으로 접근하기 어려움
- 최근 버전에서는 InnoDB의 트랜잭션과 잠금, 잠금 대기 중인 트랜잭션 목록 조회 기능 방법 도입함
	- INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 라는 테이블 조인해서 조인하면 현재 어떤 트랜잭션이 어떤 잠금을 대기하고, 해당 잠금을 어느 트랜잭션이 가지고 있는 지 확인 가능함
-  레코드 기반 잠금 기능 제공
- 잠금 정보가 상당히 작은 공간으로 관리
- 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락 존재함

### 종류
#### 레코드 락
- (InnoDB 스토리지 엔진 하) 인덱스의 레코드를 잠그는 것
	- 인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정
- 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 레코드 자체에 대해서만 락을 걸음

#### 갭(GAP) 락
- 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
- 레코드와 레코드 사이 간격에 새 레코드가 생성(INSERT) 되는 것을 제어함

#### 넥스트 키 락
- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를만들어내도록 보장하는 것이 주 목적


#### 자동 증가 락
- AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, InnoDB 스토리지 엔진에서 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용하게 됨
- INSERT와 REPLACE 쿼리 문장과 같이 새 레코드를 저장하는 쿼리에서만 필요
	- 트랜잭션과 관계없이 INSERT, REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제
- UPDATE, DELETE 등의 쿼리에서 걸리지 않음
- 

## 인덱스와 잠금
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 함
- 만약 인덱스가 하나라도 없다면 테이블을 풀 스캔하면서 테이블에 있는 모든 레코드를 잠그게 됨


## 레코드 수준의 잠금 확인 및 해제
- 테이블 수준의 잠금에서는 잠금 대상이 테이블 자체
- 레코드 수준의 잠금에서는 테이블의 레코드 각각에 잠금이 걸림
- MySQL 5.1 이전에는 레코드 잠금에 대한 메타 정보를 제공하지 않아 확인이 어려움
- MySQL 5.1 이후에서는 레코드 잠금과 잠금 대기에 대한 조회가 가능해짐
	- information_schema 라는 DB에 INNODB_TRX라는 테이블과 INNODB_LOCKS, INNODB_LOCK_WAITS 라는 테이블을 통해 확인 가능
		- MySQL 8.0 버전부터 performance_schema의 data_locks, data_lock_waits 테이블로 대체중

# MySQL 격리 수준
- 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할 지 말지를 결정하는 것
- 격리 수준은 SERIALIZABLE 격리 수준이 아니라면 크게 성능이 개선이나 저하가 발생하지 않음

## READ UNCOMMITTED
- 더티 리드가 허용되는 격리 수준
	- 더티 리드(Dirty read) = 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션이 볼 수 있는 현상
- RDBMS 표준에서는 정합성에 문제가 많은 격리 수준
	- 최소한 READ COMMITTED 이상의 격리 수준 사용 권장

## READ COMMITTED
- 오라클 DBMS에서 기본으로 사용되는 격리 수준
	- 온라인 서비스에서 가장 많이 선택되는 격리 수준
- 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT 완료된 데이터만 트랜잭션에서 조회할 수 있는 것
	- 만약 사용자 A가 UPDATE 쿼리를 처리하는 도중에 사용자 B가 조회를 할 경우, Undo 로그에 있는 변경 전 데이터를 조회함
- NON-REPEATABLE READ라는 부정합 문제 가능성 존재함
	- 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋남
	- **웹 프로그램에서는 크게 문제가 안되지만 금전적인 처리와 연결되면 문제가 발생할 수 있음**
		- 입금과 출금 처리가 계속 진행될 때, 다른 트랜잭션에서 입금된 금액 총합을 조회할 경우, REPEATABLE READ가 보장되지 않아서 SELECT 쿼리 실행될 때 마다 다른 결과를 가져오게 됨
- READ COMMITTED 격리 수준에서 트랜잭션 내에서 실행되는 SELECT 문장과 외부에서 실행되는 SELECT 문장의 차이 별로 없음


## REPEATABLE READ
- InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 함
- MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞 선 Undo 영역의 데이터 삭제할 수 없음
	- 모든 InnoDB 트랜잭션은 고유한 트랜잭션 번호를 가지며, Undo 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함되어 있음
	- Undo 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제 진행됨
- PHANTOM READ 부정합 문제가 발생할 수 있음
	- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상
	- 하지만 **InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서는 해당 문제 발생하지 않음**

## SERIALIZABLE
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 격리 수준
- InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서 PHANTOM READ 문제가 잘 발생하지 않기에 굳이 쓸 필요 없음


기타
- MySQL 서버 구성은 소스 서버와 레플리카 서버로 구성
- 백업은 레플리카 서버에서 실행
- MySQL 서버의 DDL은 단일 스레드로 작동함
- 레코드락은 다른 상용 DBMS 엔진에서는 레코드 자체만을 잠근다.
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용하고 또한 innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화(0으로 설정)되면 넥스트 키 락 방식으로 잠금이 걸림
- 자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유가 AUTO_INCREMENT 잠금을 최소화하기 위함
