# MVCC(Multi Version Concurrency Control)

- 멀티 버전 = 하나의 레코드에 대해 여러 개의 버전이 동시에 관리되는 것
	- UPDATE문을 작동할 경우, InnoDB 버퍼풀에는 변경된 데이터가, Undo 로그에는 변경 전의 값, 디스크 파일에는 새로운 값으로 업데이트 되었거나 되지 않은 상태, 총 2가지 버전이 존재하게 된다.
- MVCC는 격리 수준에 따라 어느 영역을 읽어올 지 결정하는 과정을 뜻함

## 잠금 없는 일관된 읽기
- MVCC는 잠금을 사용하지 않는 일관된 읽기 기능을 제공하는 것이 가장 큰 목적이다.
	- 격리 수준이 READ_UNCOMMITTED인 경우에는 변경된 데이터를 읽어서 반환
	- 격리 수준이 READ_COMMITED 혹은 그 이상인 경우에는 Undo 로그 영역의 데이터 반환
- 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업 가능함
	- SERIALIZABLE이 아니면 순수한 읽기 작업은 다른 트랜잭션 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행됨

## Undo 로그
- DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한 데이터 의미
- 트랜잭션과 격리 수준을 보장하는 데 사용된다.

### Undo 로그 모니터링
- MySQL 5.5 이전 버전에서는 한 번 증가한 Undo 로그 공간은 다시 줄어들지 않음
	- 100GB 크기의 테이블을 DELETE로 삭제하면 Undo 로그 공간에 복사되어야 함
- 트랜잭션이 오랜 시간 동안 실행될 때도 Undo 로그의 양은 급격히 증가할 수 있음
	- A, B, C 트랜잭션 중에서 B,C가 완료되었지만 가장 먼저 시작한 A 트랜잭션이 끝나지 않았으면 B, C에서 수행한 UPDATE, DELETE 실행으로 인한 Undo 로그가 존재하고 또 A 트랜잭션이 끝나지 않아서 삭제되지도 않는다.
- MySQL 8.0 버전에서는 Undo 로그를 돌아가면서 순차적으로 사용해 디스크 공간 줄이는 것 가능함, 때로는 필요 시점에서 사용 공간을 자동으로 줄여주기도 함

### Undo 테이블스페이스 관리
- Undo 로그가 저장되는 공간을 Undo 테이블스페이스라고 함
- MySQL 8.0에서부터는 항상 시스템 테이블 스페이스 외부의 별도 로그 파일에 기록되도록 개선됨
- 하나의 롤백 세그먼트는 InnoDB 페이지 크기를 16바이트로 나눈 값의 개수만큼 Undo 슬롯을 가짐
	- ex) InnoDB 페이지 크기 = 16KB -> 하나의 롤백 세그먼트 = 1024개 Undo 슬롯 가짐
- 하나의 트랜잭션이 필요로 하는 Undo 슬롯 개수 = INSERT, UPDATE, DELETE 문장 특성에 따라 최대 4개 Undo 슬롯 사용함
	- 일반적으로는 하나의 트랜잭션은 대략 2개 정도 사용함
- 최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (Undo 테이블스페이스 개수)
- 일반적인 설정 16KB InnoDB에서 기본 설정 사용 시(innodb_undo_tablespaces=2, innodb_rollback_segments=128), 대략 131,072개 트랜잭션을 동시에 처리 가능함


---

# 트랜잭션
- 작업의 완전성을 보장해주는 것 = 데이터의 정합성을 보장하기 위한 기능
	- 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT을 실행했을 경우) 아무것도 적용되지 않아야 함(오류 발생했을 경우)을 보장해주는 것
	- 부분 업데이트 현상으로 인해 실패 재처리 작업을 진행하지 않아도 됨
- 원상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 것
- InnoDB는 쿼리 중 일부라도 오류 발생 시 전체를 원 상태로 돌림 (= 트랜잭션 적용)
- MyISAM에서는 쿼리 중 일부가 오류 발생을 하더라도 부분 업데이트를 진행함
	- ex) 1이란 값을 넣은 뒤, {1, 2, 3}을 넣으면 1이 중복되어서 오류가 발생하지만 2, 3은 없어서 부분 업데이트가 진행됨

# 잠금
- 동시성을 제어하기 위한 기능
- 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨 잠금으로 나눌 수 있음
	- MySQL 엔진 잠금은 모든 스토리지 엔진에 영향을 미침
	- 스토리지 엔진 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음
- 기타 : 메타데이터 락 = 테이블 구조를 잠그는 기능, 네임드 락 = 사용자 필요에 맞게 사용할 수 있는 잠금 기능

## 종류
### 글로벌 락
- FLUSH TABLES WITH READ LOCK 명령으로 획득 가능
- 잠금 가운데 범위가 가장 큼 = MYSQL 서버 전체
	- 한 세션에서 글로벌 락을 걸면 다른 세션에서는 SELECT를 제외한 대부분의 DDL, DML 문장 실행 시, 글로벌 락 해제 전까지 대기 상태로 남음
	- 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향 미침
- 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업 받을 때 글로벌 락 사용함
#### 백업락
- InnoDB 스토리지 엔진에서는 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요 없음 - MySQL 8.0부터 Xtrabackup 이나 Enterprise Backup 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됨
- 특정 세션에서 백업락을 걸면 모든 세션에서 테이블의 스키마나 사용자 인증 관련 정보 변경할 수 없게 됨
	- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
	- REPARI TABLE과 OPTIMIZE TABLE 명령
	- 사용자 관리 및 비밀번호 변경
- 일반적인 테이블 데이터 변경은 허용됨
	- DDL 명령 실행되면 복제를 일시 중지하는 역할 수행


### 테이블락
- 개별 테이블 단위로 설정되는 잠금
- MyISAM, InnoDB 스토리지 엔진에서도 동일하게 설정 가능함
- 일반적으로 특별한 상황이 아니면 사용할 일 없음
- 명시적, 묵시적으로 특정 테이블의 락 걸 수 있음
	- 명시적
		- LOCK TABLE {table_name} \[READ | WRITE]
		- 잠금 해제(반납)은 UNLOCK TABLES 명령으로 가능함
	- 묵시적 
		- MyISAM이나 MEMORY 테이블의 데이터를 변경하는 쿼리 실행하면 발생함
			- 데이터가 변경되는 테이블에 잠금 설정하고 데이터를 변경한 후, 즉시 잠금 해제하는 형태
		- InnoDB에서는 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 단순 데이터 변경으로 묵시적 테이블 락 설정되지 않음
			- 대부분의 데이터 변경 쿼리(DML)에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침


### 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금 설정 가능함
- 단순히 사용자가 지정한 문자열(String)에 대해 잠금을 걸고 해제하는 기능
- 여러 클라이언트가 상호 동기화를 처리해야 할 때, 네임드 락을 이용하면 쉽게 해결 가능
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용 가능함
	- 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리 실행하면 한꺼번에 많은 레코드를 변경할 때, 발생하는 데드락 문제를 해결할 수 있음
```SQL
SELECT GET_LOCK('네임드락을 걸 특정 문자열', 시간(초단위))
-- 잠금 사용중이라면 초 동안만 대기하다가 자동으로 해제됨

SELECT IS_FREE_LOCK('네임드락을 걸 특정 문자열')
-- 문자열에 대해 잠금이 있는지 확인

SELECT RELEASE_LOCK('네임드락을 걸 특정 문자열')
-- 문자열에 대해 획득했던 잠금을 반납(헤제)

-- 정상적으로 락을 획득하거나 해제하면 1, 아니면 Null 또는 0 반환

```


### 메타데이터 락
- 데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경하는 경우에 자동으로 획득하는 잠금


## InnoDB 스토리지 엔진 잠금
- MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 제공하는 레코드 기반 잠금 방식
- MyISAM보다 뛰어난 동시성 처리 기능 제공함
- 이원화된 잠금 처리 탓에 MySQL 명령으로 접근하기 어려움
- 최근 버전에서는 InnoDB의 트랜잭션과 잠금, 잠금 대기 중인 트랜잭션 목록 조회 기능 방법 도입함
	- INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 라는 테이블 조인해서 조인하면 현재 어떤 트랜잭션이 어떤 잠금을 대기하고, 해당 잠금을 어느 트랜잭션이 가지고 있는 지 확인 가능함
-  레코드 기반 잠금 기능 제공
- 잠금 정보가 상당히 작은 공간으로 관리
- 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락 존재함

### 종류
#### 레코드 락


#### 갭(GAP) 락


#### 넥스트 키 락


#### 자동 증가 락










기타
- MySQL 서버 구성은 소스 서버와 레플리카 서버로 구성
- 백업은 레플리카 서버에서 실행
- MySQL 서버의 DDL은 단일 스레드로 작동함