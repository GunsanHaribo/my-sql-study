# 키워드
- GPT 요약 참고

# 질문
- MySQL에서 여러 트랜잭션이 동시에 들어오면 어떻게 처리할까? InnoDB에서
- MySQL에서는 트랜잭션을 어떻게 구현할까?
- 언제를 기점으로 트랜잭션이 보장되야 되는가? 항상 커밋 시점인가? 
- 각각의 격리 수준은 어떤 리드들을 방지하나요?
- 래치하고 뮤택스하고 다른게 뭔가요?

# 단원 정리
## 1. 트랜잭션
- 논리적인 작업 전체가 100% 적용되거나 아무것도 적용되지 않아야한다
- InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 Insert 문장을 실행 하기전 상태로 그대로 복구, 다른 엔진들은 트랜잭션 기능 없음
- 주의사항 : DBMS의 커넥션과 동일하게 꼭 피룡한 최소의 코드에만 적용하는 것이 좋다. 
  - 커넥션을 소유하는 시간이 길면 안됨(ex, 트랜잭션안에서 네트워크 접근)
  - "게시글 내용 저장과 게시글 첨부파일 정보 저장"같이 정합성이 보장되야만 하는 부분만 트랜잭션으로 

## 2. MySQL 엔진 잠금 
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미침, 단 스토리지 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다
- 락의 종류와 기능 
  1. 글로벌락 : MySQL 서버의 모든 변경 작업을 멈춘다
     - 사용 이유(백업) : MyISAM이나 Memory 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 떄
     - 제한 범위 : 다른 모든 세션의 INSERT, UPDATE, DELETE, ALTER, CREATE 등이 모두 대기 상태
     - 백업락(경량 글로벌락) : DML은 허용 DDL은 제한
       - DDL은 Undo Log에 기록되지 않아 트랜잭션 시점 제어 불가.
       - 백업 중 DDL이 발생하면 서로 다른 시점의 스키마가 섞임.
       - 결과적으로 복원 시 구조 불일치·파싱 오류·무결성 깨짐 발생.
         - 백업은 시점을 고정해 일관성을 유지해야 하지만, 복제는 DDL로 시점을 변화시키므로 충돌을 피하기 위해 백업 중에는 복제를 일시 중지한다.
         - 다만, 다른 시점을 백업한다고 했을떄 발생하는 문제들은 정확히 모르겠음
       - 복제시에 스키마 구조등등을 일관성있게 유지하기 위해서 DDL이 시작되면 복제를 일시 중지하는 역할을 함
  2. 테이블락 : 개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 특정 테이블락을 획득할 수 있다.
     - 사용 이유 : DDL
     - 제한 범위 : 한 테이블
  3. 네임드락 : 데이터에 대한 작업을 논리적으로 묶는 역할
     - 사용 이유 : 여러 클라이언트가 상호 동기화, 배치 프로그램
       - 두 서버가 동시에 “하루 정산 배치”를 돌림
         - 같은 테이블의 데이터가 중복 업데이트됨
         - Row Lock은 테이블 안에서만 작동하니, 두 서버는 서로 모르고 실행함.
       - 네임드락으로 해결 
         - SELECT GET_LOCK('daily_settlement_job', 10); -> 해당 이름으로 배치처리
           - 다른 서버가 동일한 이름으로 요청하면 대기 or 실패
     - 제한 범위 : 같은 이름 
  4. 매타 데이터락: 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우 획득하는 잠금
     - 사용 이유 : 데이터베이스 객체의 정의(Definition) 를 보호
       - 책의 예시는 메타데이터 잠금과 InnoDB의 트랜잭션을 동시에 사용해야 하는 경우도 나옵니다.
     - 제한 범위 : 객체 단위 (테이블, 뷰, 함수 등) — 해당 객체에만 영향

## 3. InnoDB 스토리지 엔진 잠금
- InnoDB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS or performance_schema로 잠금정보 조회가능
- 스토리지 엔진의 내부잠금은 세마포어를 사용함
1. 락의 종류
   1. 레코드(행)락
      - 범위가 상당히 작아서 레코드 락 레스컬레이션 현상은 없다.
      - 레코드 자체가 아니라 인덱스의 레코드를 잠금
   2. 갭락
      - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어
      - “다른 트랜잭션이 내 쿼리 조건에 맞는 ‘추가된 레코드(팬텀)’를 중간에 INSERT하는 것을 막기 위해.” 
      - age BETWEEN 20 AND 30 사이에 25들어오면 갑자기 새로운 데이터가 보임
   3. 넥스트 키락 
      - 레코드락과 갭락을 합쳐놓은 형태
      - 넥스트 키락 현재 레코드와 그 앞의 간격락
      - Reaptable read와  innodb_locks_unsage_for_binlog 시스템 변수가 비활성화되면 활용
      - 인덱스 상에서 직전 엔트리(previous index entry)를 기준으로 잠금
   4. 자동 증가 락
      - 새로운 insert시 순간에 락, 테이블 전체 수준
2. 인덱스와 잠금
   1. 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리, 변경해야할 레코드를 찾기위해 검색한 레코드를 모두락으로 걸어야한다.
      - 만약에 레코드 조회시 2가지 컬럼 중 인덱스가 없는 부분이 있다면, 인덱스가 있는 컬럼의 레코드들이 다 잠긴다. : 인덱스가 없으면 테이블 전체가 잠기는 테이블 스캔(lock escalation)
   2. 레코드 수준의 잠금 확인 및 해제
      - 레코드 수준의 잠금은 크기가 작아서 오랜 시간동안 잠겨진 상태로 남아있어도 잘 발견되지 않을 수 있다.
      - 교재에서는 인포테이블을 조인해서 어떻게 하면 현재 잠금 상태를 보는 방법을 알려줍니다. 


## 3. 트랜잭션 간의 격리(고립) 격리수준
- 여러 트랜잭션이 동시에 처리될 떄 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정
1. Read Uncommited(사용 안함)
  - 각 트랜잭션에서의 변경 내용이 Commit, rollback 여부와 상관없이 다른 트랙잭션에서 보이는 것
2. Read Commited(오라클에서 주로 사용)
   - 커밋이 완료된 데이터만 다른 트랜잭션에서 조회 
   - A 트랜잭션이 UPDATE를 하면, 기존 값은 언두 로그 영역에 백업됨. -> B 트랜잭션이 SELECT를 실행하면, 해당 레코드가 아직 커밋되지 않았을 경우 언두 로그의 이전 버전을 읽음
   - 하지만, 같은 쿼리를 두 번 실행하면 다른 결과가 나올 수 있음.(다른 트랜잭션이 커밋되면, 언두 로그 대신 새로운 값을 읽기 때문)
3. Repeatable Read(MySQL에서 주로 사용)
  - REPEATABLE READ는 트랜잭션이 시작된 시점의 데이터를 스냅샷으로 유지해, 이후 다른 트랜잭션이 커밋하더라도 항상 같은 데이터를 읽습니다.
  - InnoDB는 각 레코드에 DB_TRX_ID를 저장하고, 자신보다 작은 트랜잭션 번호의 데이터만 읽어 MVCC를 구현합니다.
  - 이 때문에 커밋된 변경 사항도 트랜잭션이 끝나기 전에는 반영되지 않습니다.
  - 단, 트랜잭션 시작 이후 삽입된 새 레코드는 스냅샷에 포함되지 않아 보이지 않는 부정합이 생깁니다.
  - InnoDB는 갭 락과 넥스트 키 락을 사용해 이러한 상황에서도 팬텀 리드를 방지합니다.
4. Serializable(사용 안함)
   - 트랜잭션을 완전히 직렬화(serialized) 하여 처리함. 
   - 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없게함
   - 내부적으로 SELECT 문도 자동으로 공유락(Shared Lock) 을 걸기 때문에 동시성이 크게 떨어짐.