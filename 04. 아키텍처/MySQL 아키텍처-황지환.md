```text
[프로그래밍 API]
 └─ Java, C/C++, .NET, PHP, Python, Perl, Ruby, Go ...
 
    ┌ 1. [MySQL 서버]
      
       ┌ 1-1. [MySQL 엔진]
                        ▲                    
                    커넥션 핸들러
                        ▼
       ┌─────────────────────────────────────┐
       │ SQL 인터페이스                     │
       │ SQL 파서                           │     
       │ SQL 옵티마이저                     │      
       │ 캐시 & 버퍼                        │
       └─────────────────────────────────────┘
       └                                      
                       ▲
       ┌ 1-2. [스토리지 엔진 API]
       ┌─────────────────────────────────────┐
       │ InnoDB │ MyISAM │ Memory            │   
       └─────────────────────────────────────┘
       └ 
    └               
[운영체제, 하드웨어]  
                       ▲
               ┌───────────────┐
               │ 데이터 파일    │
               │ 로그 파일     │                    [디스크]              
               └───────────────┘
```

# 단원별 키워드
## 1. MySQL 엔진 아키텍처
### 1-1. 구성 요소 
1. MySQL 엔진
2. 스토리지 엔진
3. 핸들러 API
### 1-2. MySQL 스레딩 구조
1. 포그라운드 스레드(클라이언트 스레드
2. 백그라운드 스레드
### 1-3. 메모리 할당 및 사용 구조
1. 글로벌 메모리 영역
2. 로컬 메모리 영역
### 1-4. 플러그인 스토리지 엔진 모델
### 1-5. 컴포넌트
### 1-6. 쿼리 실행 구조
1. 쿼리 파서
2. 전처리기
3. 옵티마이저
4. 실행 엔진
5. 핸들러
### 1-7. 복제
### 1-8. 쿼리 캐시
### 1-9. 스레드 풀
### 1-10. 트랜잭션 지원 메타 데이터

## 2. Inno DB 스토리지 엔지 아키텍처
### 2-1. 프라이머리 키에 의한 클러스터링
### 2-2. 외래 키 지원
### 2-3. MVCC
### 2-4. 잠금 없는 일관된 읽기(Non-Lock Consistent Read)
### 2-5. 자동 데드락 감지 
### 2-6. 자동화된 장애 복구
### 2-7. InnoDB 버퍼 풀
1. 버퍼풀의 크기 설정 
2. 버퍼 풀의 구조
3. 버퍼 풀과 리두 로그
4. 버퍼 풀 플러시
   1. 플러시 리스트 플러시
   2. LRU 리스트 플러시
5. 버퍼 풀 상태 백업 및 복구
6. 버퍼풀의 적재 내용 확인 
### 2-8. Double Write Buffer
### 2-9. 언두 로그
1. 언두 로그 모니터링 
2. 언두 테이블스페이스 관리
### 2-10. 체인지 버퍼
### 2-11. 리두로그 및 로그버퍼
1. 리두 로그 아카이빙
2. 리두 로그 활성화 및 비활성화
### 2-12. 어댑티브 해시 인덱스
### 2-13. InnoDB와 MyISAM, Memory 스토리지 엔진 비교

## 3. MyISAM 스토리지 엔지 아키텍처
## 4. MySQL 로그 파일

---

# 내용 정리
## 1. MySQL 엔진 아키텍처
### 1-1. 구성 요소
1. MySQL 엔진
2. 스토리지 엔진
   1. 디스크 스토리지로 부터 데이터를 읽어오는 부분
   2. MySQL 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있음
   3. CREATE TABLE test_table (...) ENGINE=INNODB;
3. 핸들러 API
   1. 읽기 쓰기 요청 API
### 1-2. MySQL 스레딩 구조
- 엔터프라이즈 모델은 스레드 모델이아닌 스레드 풀 모델을 사용, 이떄는 커넥션 : 포그라운드 스레드 = 1:N 관계
1. 포그라운드 스레드(클라이언트 스레드)
   1. 클라이언트가 사용자가 요청하는 쿼리 문장을 처리
   2. 커넥션을 종료하면 스레드 다시 스레드 캐시로 돌아감, 스레드 캐시에 일정 개수이상의 스레드가 있으면 스레드 제거
   3. 버퍼나 캐시로 부터 데이터를 가져옴, 없으면 데이터나 인덱스 파일로 부터 읽어옴, InnoDB는 버퍼로부터 디스크까지 기록하느 작업은 백그라운드 스레드가 처리
2. 백그라운드 스레드
   1. 5가지정도 역할을 하는 쓰레드가 있으나 중요한건, 
      1. 로그 스레드
      2. 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 쓰레드 -> 버퍼가 뭐지? 
   2. 쓰기 버퍼링 기능을 사용할 수 있음 
### 1-3. 메모리 할당 및 사용 구조
1. 글로벌 메모리 영역
   1. 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당
      - 테이블 캐시
      - InnoDB 버퍼 풀
      - InnoDB 어댑티브 해시 인덱스
      - InnoDB 리두 로그 버퍼
2. 로컬 메모리 영역
   1. 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
      - 정렬 버퍼
      - 조인 버퍼
      - 바이너리 로그 캐시
      - 네트워크 버퍼
### 1-4. 플러그인 스토리지 엔진 모델
- 전문 검색 엔진을 위한 검색어 파서등등 커스컴해서 플러그인을 추가할 수 있다.
1. MySQL 엔진과 스토리지 엔진의 처리영역
   - MySQL 엔진이 스토리지 엔진을 사용하려면 핸들러를 사용해야한다.
   - 읽고 쓰는 것만 스토리지, Group By나 order by등 복잡한 처리는 MySQL엔진이 처리
   1. MySQL 엔진의 처리 영역:
      - SQL 파서
      - 옵티마이저
      - SQL 실행기
   2. 스토리지 엔진의 처리 영역:
      - 데이터 읽기/쓰기
### 1-5. 컴포넌트
- 비밀 번호 검증 등등,,
### 1-6. 쿼리 실행 구조
1. 쿼리 파서
   - 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만드어 내는 작업(Interpreter 패턴)
2. 전처리기
   - 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인 
3. 옵티마이저
   - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정, DBMS의 두뇌
4. 실행 엔진
   - DBMS의 손과 발, 핸들러와 소통하면서 데이터를 읽어오게 시킴
5. 핸들러
   - 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할, 여기서는 스토리지 엔진
### 1-7. 복제
- 16장에서 다룰 예정
### 1-8. 쿼리 캐시
1. SQL의 실행결과를 메모리에 캐시하고, 동일 SQL쿼리가 실해오디면 테이블을 읽지 않고 즉시 결과를 반환
2. 중간에 테이블의 데이터가 변경되면, 변경된 테이블과 관련된 것들을 모두 Invalidate해야되서 성능 저하 유발(큰 도움이 않됨)
### 1-9. 스레드 풀
1. [스레드 풀을 사용하면 더 느려지는 사례와, 왜 눈에 띄는 성능 향상을 보여주지 않는지는 추후 조사 예정]
2. Percona Server의 스레드 풀 플러그인은 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능을 제공
   - 트랜잭션이 미리 시작됬으면 쿼리가 나중에 들어와도 먼저 처리해줌
### 1-10. 트랜잭션 지원 메타 데이터
1. 데이블 구조 정보와 스토어드 프로그램등 정보를 데이터 딕셔너리 또는 메타 데이터라고 하는데 이전에는 생성, 변경중 비정상적으로 종료가 되면 그대로 남는 문제가 있었다.
2. 그래서 이런 메타 데이터들을 InnnoDB 테이블에 저장하도록 개선됐다.
   - Json으로 덤프도 가능 
## 2. Inno DB 스토리지 엔지 아키텍처
- 레코드 기반(행기반)의 잠금을 제공 -> 높은 동시성 처리가 가능
### 2-1. 프라이머리 키에 의한 클러스터링
- InnoDB에서는 프라이머리 키(PK)를 지정하면, 그 순간 자동으로 클러스터드 인덱스(Clustered Index)로 저장 -> (추후에 클러스터링 인덱스 할떄 세부 조사)
### 2-2. 외래 키 지원
- 외래키는 서비스 운영할때 불편해서 생성하지 않는 경우가 있는데, 개발할떄는 좋은 가이드 역할을 할 수 있다고 함
1. 외래키의 까다로운점
- InnoDB에서는 외래키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고 삭제 변경등등 그렇게 간단하지 않다
- forign_key_checks off를 통해서 체크 작업을 일시적으로 멈출 수 있습니다.
### 2-3. MVCC(멀티 버전)
- 잠금을 사용하지 않는 일관된 읽기를 제공
- 언두 로그를 이용해 구현
- 하나의 레코드에 대해서 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러가지 상황에 따라 달라지는 구조
### 2-4. 잠금 없는 일관된 읽기(Non-Lock Consistent Read)
- 격리 수준이 Serializable이 아닌 Read_uncommitted나 read_committed, repeatable_read 수준인 경우 insert와 연결되지않은 순수한 읽기 작업은 항상 잠금 대기하지 않고 실행
- 트랜잭션이 너무 길면 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야하기때문에 속도가 느려질 수 있다.
### 2-5. 자동 데드락 감지
- 잠금 대기 목록(Wait for List)을 그래프 형태로 관리
- 데드락 감시 스레드가 주기적으로 잠금 대기 그래프를 검사해 트랜잭션 삭제 : 언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상
- 동시성 처리를 할게 많아지면, 서비스 쿼리를 처리중인 스레드는 작업을 더 진행하지 못하고 대기하면서 서비스에 악영향
- innodb_deadlock_detect와 innodb_lock_waite_timeout을 낮은 시간으로 변경해서 사용할 것을 권장
### 2-6. 자동화된 장애 복구
- 디스크나 서버 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구를 못하는 경우도 있음 , 이떄는 복구하기 힘듬
- innodb_force_recovery 옵션을 사용해서 복구합니다. 1~6가지 방법이 있스빈다.
- 최후의 방법으로는 데이터베이스를 새로 구축하고, 바이너리 로그르 사용해 최대한 장애 시점까지 복구할 수도 있습니다..
### 2-7. InnoDB 버퍼 풀(캐시)
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄작업으로 처리할 수 있게 해주는 버퍼
1. 버퍼풀의 크기 설정
   - 서버에다가 증설을 한다면 50%에서 점점 올려가는 방법으로 진행
   - 128MB 단위로 쪼개어 관리 됩니다.
2. 버퍼 풀의 구조(LRU, Flush, Free)
   - 페이지로 쪼개서 데이터를 안에 저장
      1. LRU
         - LRU와 MRU 리스트가 결합된 형태
         - Old 서브리스트 영역을 LRU, New 서브리스트 영역은 MRU(나이가 부여됨)
      2. Flush
         -  리두 로그 공간의 재활용, 리두 로그 엔트리가 사용하는 공간을 비운다
         - 더티 페이지를 관리하는 리스트
      3. Free
         - 어떤 데이터 페이지도 없는 곳 
3. 버퍼 풀과 리두 로그(다음주 예정)
   - 데이터 캐시와 쓰기 버퍼링
   - 쓰기 버퍼링이 리두로그와 관련이 있다. 
   - (나머지는 추후 예정)
4. 버퍼 풀 플러시
   - 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화 하기 위해 2개의 플러시 기능 실행 
   1. 플러시 리스트 플러시
      - (추후 작성 예정)
   2. LRU 리스트 플러시
      - 사용 빈도가 낮은 페이지 내보낸다. 
5. 버퍼 풀 상태 백업 및 복구
   - 셧다운하기 전에 다음과 같이 innodb_buffer_pool_dump_now 시스템 변수를 통해 버퍼풀의 상태를 다시 복구할 수 있다.
   - 이전에는 웜업으로 풀스캔 이후에 진행
6. 버퍼풀의 적재 내용 확인
   - innodb_cached_indexes 테이블을 통해서 테이블의 인덱스 별로 적재량 확인 가능
### 2-8. Double Write Buffer
- 더티 페이지를 디스크 파일로 플로시할때 일부가 기록되는 걸 방지하기 위함 
- 디스크에 기록하기전에 DoubleWirte버퍼에 기록해서 일부만 기록되지 않도록 사용
### 2-9. 언두 로그
- 트랜잭션 보장, 격리 수준 보장을 하기 위해서 사용
1. 언두 로그 모니터링
2. 언두 테이블스페이스 관리
### 2-10. 체인지 버퍼
- 인덱스를 업데이트 하는 작업은, 랜덤하게 인덱스를 읽는 작업이 필요해서 시간이 오래걸림
- 변경해야할 인덱스 페이지가 버퍼풀에 없으면, 이를 임시공간에 저장해놓고 바로 사용자에게 결과를 바노한하는 형태
### 2-11. 리두로그 및 로그버퍼(다음주에..)
1. 리두 로그 아카이빙
2. 리두 로그 활성화 및 비활성화
### 2-12. 어댑티브 해시 인덱스
- Inno스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자도응로 생성하는 인덱스
- B-Tree 검색 시간을 줄여주기 위해 도입된 기능 -> B트리를 탐색하지 않고 저장된 데이터 페이지를 바로 찾아갈 수 있도록
- 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리, 히트율이 낮는다면 꺼서 메모풀이 많은 메모리를 잡을 수 있게 하는것도 방법
### 2-13. InnoDB와 MyISAM, Memory 스토리지 엔진 비교
- MyIsam 스토리지 엔진은 성능이 안좋다. 메모리 엔진은 테이블 수준락으로 성능이 안좋다.