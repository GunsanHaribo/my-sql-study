
<img width="9411" height="1555" alt="Pasted image 20250923200800" src="https://github.com/user-attachments/assets/fda05d05-b9b2-4996-9bb1-691410c03e5e" />

MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구성되어있다.
MySQL엔진과 스토리지 엔진 사이에는 핸들러 API가 존재하는데 핸들러 API는 두 엔진 사이의 응답을 주고 받는 인터페이스다.


# MySQL 스레딩 구조
포그라운드 스레드와 백그라운드 스레드로 구성되어있으며
포그라운드 스레드는 클라이언트 스레드라고도 불린다.

### 포그라운드 스레드(클라이언트 스레드)
- 클라이언트 요청을 처리하는 스레드
- 커넥션 연결 수 만큼 존재
- 연결 종료 시, 스레드 캐시로 이동하게 된다.

InnoDB엔진에서의 포그라운드 스레드
	데이터 버퍼, 캐시에 데이터를 읽어서 저장하는 일 담당
	대부분 읽기 작업을 진행

MyISAM엔진에서의 포그라운드 스레드
	데이터 읽기와 더불어 쓰기 작업까지 담당
	지연 쓰기 기능 X



### 백그라운드 스레드(InnoDB 엔진 입장에서 백그라운드 스레드)
지연 쓰기(쓰기 버퍼링) 기능을 담당한다.
	! 지연 쓰기란? 버퍼 공간에 쓰기 작업 결과를 모아두었다가 한 번에 쓰는 기법
	디스크 동기화 작업이 없어서 속도가 빠르다.

스레드 종류
	InnoDB 버퍼풀로부터 디스크 쓰기 스레드
	로그 기록 스레드
	인서트 버퍼 병합 스레드
	데이터를 버퍼로 읽어 오는 스레드
	잠금, 데드락 모니터링 스레드


## 메모리 할당 및 사용 구조
### 글로벌 메모리 영역
하나의 메모리 공간만 할당
#### 종류
InnoDB 어댑티브 해시 인덱스

**캐시**
	MyISAM 키 캐시
	테이블 캐시

**버퍼**
	InnoDB 버퍼 풀
	redo 로그 버퍼
	바이너리 로그 버퍼


### 섹션(커넥션) 메모리 영역
각 섹션별로 독립적으로 할당
절대 공유되지 않는다.

#### 종류
바이너리 로그 캐시

결과 버퍼, 네트워크 버퍼
	커넥션 연결동안 계속 할당하는 특징을 가짐

Join 버퍼, Sort 버퍼
	쿼리 실행 시에만 할당되며 이후 해체

# MySQL 엔진
### SQL 파서
쿼리 문장을 토큰으로 분리, 트리 형태 구조로 만든다.
문법 오류를 체크

### SQL 전처리기(분석)
구조적 오류를 확인한다.
	테이블명, 컬럼명, 내장함수 존재 유무 확인
	접근 권한 확인

### SQL 옵티마이저
쿼리를 비용으로 변환시킨 뒤, 비용 최적화 알고리즘을 통해 최적의 실행계획을 세우고 작동한다.
DBMS의 뇌에 해당

### SQL 실행 엔진
만들어진 실행 계획에 따라 각 핸들러에게 요청을 보낸다.
핸들러에게 받은 결과를 다시 또 다른 핸들러에게 요청을 보낼 수도 있다.


# InnoDB 스토리지 엔진 아키텍쳐
<img width="862" height="608" alt="image" src="https://github.com/user-attachments/assets/1d6bd971-827a-4e46-8956-95180a68a023" />


데이터 읽기 및 쓰기 작업 담당

MySQL 8.0 미만 버전에서는 플러그인을 통해서 스토리지 엔진을 업데이트하고 추가 기능을 넣었다.

MySQL 8.0 이상에서는 컴포넌트를 통해 업데이트 및 추가 기능을 넣는다.

## 기능
### 성능 최적화
#### InnoDB 버퍼풀
- 디스크 데이터 파일, 인덱스 정보를 메모리에 캐시 해두는 공간
- 쓰기 버퍼링(지연 쓰기) 기능 담당

##### 크기 설정
128MB 청크 단위로 쪼개어서 관리
하나의 버퍼 풀을 여러 개의 작은 개별 버퍼 풀로 쪼개어서 관리함
	이를 버퍼 풀 인스턴스라고 함

버퍼 풀 크기를 크게 설정할 수록 데이터 캐시 기능이 향상되면서 쿼리 성능이 향상된다.

**실무**
- OS 전체 메모리 8GB 미만 - 50% 정도만 버퍼풀 메모리에 할당
- 8GB 이상 - 50%에서 조금씩 올리면서 조정
- 50GB 이상 - 대략 20~35GB 할당
- innodb_buffer_pool_size : 버퍼 풀 크기 조절
	크기 조절은 상당히 크리티컬한 변경: 한가할 때 수행 + 줄이는 작업은 서비스 영향이 크므로 주의해야함
- innodb_buffer_pool_instance: 버퍼 풀 갯수 관리
	- 전체 버퍼 풀 메모리 크기 1GB 미만 = 1개
	- 전체 버퍼 풀 메모리 크기 40GB 이하 = 8개
	- 전체 버퍼 풀 메모리 크기 40GB 초과 = 각 인스턴스 당 5GB되게 개수 설정


##### 구조
**Free 리스트**
	비어있는 페이지 목록: 쿼리가 디스크 데이터 페이지를 읽을 때 사용(프리 리스트 -> 클린 페이지)
**LRU 리스트**
- 캐시의 핵심
- LRU와 MRU가 결합된 리스트 형태: 처음 한 번 읽인 데이터는 MRU 영역에서, 거의 사용되지 않은 데이터는 점점 LRU 끝으로 밀려나다가 삭제됨
- LRU 리스트 플러시
	LRU 리스트의 끝 부분부터 시작해서 정해진 변수만큼 페이지 스캔하면서 디스크 동기화하고 리스트를 청소함	(클린 페이지 -> 프리 리스트)
**Flush 리스트**
- 더티페이지(디스크 동기화되지 않은 데이터 페이지)의 변경 시점 기준 페이지 목록 관리
- Flush 리스트 플러시
	주기적으로 오래전에 변경된 데이터 페이지를 순서대로 디스크에 동기화
	redo 로그 공간 재사용을 위해서 수행(비활성화됨)
	전체 버퍼 풀이 가진 페이지의 90%까지 더티페이지 저장 가능함

##### redo 로그
- 쓰기 지연의 핵심
- 데이터 변경 시 변경 내용이 기록됨
- 각 엔트리는 특정 데이터 페이지와 연결됨 -> 1개 이상 고정 크기 파일 연결해서 순환고리 처럼 사용 = 재사용되듯이 기존 로그 엔트리는 새 로그 엔트리로 덮어쓰여짐
- 쓰여진 redo로그는 활성 redo 로그라고 하며 재사용 불가능한 공간(덮어 쓰일 수 없는 공간)임
- 매번 로그 엔트리가 기록될 때마다 LSN(Log Sequence Number)값이 증가함
- 체크 포인트
	- Flush 리스트와 동기화 + 체크포인트 당시 LSN보다 작은 redo 로그 엔트리와 더티페이지 모두 디스크 동기화(=비활성화로 만듬)
	- 가장 최근 체크포인트 LSN = 활성 redo 로그 공간 시작점
	- 가장 최근 체크 포인트 LSN - 마지막 redo 로그 엔트리 LSN = 활성 redo 로그 공간 크기

##### 버퍼 풀 상태 백업 및 복구
워밍업 : 디스크 데이터가 버퍼 풀에 적재된 상태 - 몇십 배의 쿼리 처리 속도를보임
	5.5 버전에서는 주요 테이블 & 인덱스 풀 스캔 후 서비스 운영함
	5.6 이상부터는 버퍼 풀 덤프 및 적재 기능을 통해서 백업 가능함

백업 과정
	데이터 디렉터리에 ib_buffer_pool 파일 생성 = LRU 리스트에 적재된 데이터 페이지의 메타 정보만 가져옴
	저장은 빠르게 가능하나 가져올 때는 디스크를 읽어야하기에 시간이 오래걸림



#### 체인지 버퍼
- 인덱스 페이지가 버퍼풀에 없을 때, 해당 인덱스 페이지에 적용되어야 할 변경 작업을 저장하는 임시공간
- 디스크 읽기 및 쓰기 작업을 최소화하는 역할 수행

#### 어댑티브 해시 인덱스
- 글로벌 메모리 영역에 존재
- InnoDB 엔진이 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- InnoDB 엔진에서 하나만 존재함
- B-Tree 검색 시간을 줄여주기 위해 도입함
	- 자주 읽히는 데이터 페이지의 키 값을 이용해서 해시 인덱스를 만듬
	- 해시 인덱스 = B-Tree 인덱스 고유 번호(ID) : B-Tree 인덱스 실제 값
- 내부 잠금(세마포어) 경합을 줄이기 위해 파티션 기능 제공
- 상당히 큰 메모리 공간 사용할 수 있음
- 테이블 삭제 시, 해시 인덱스도 삭제해야하므로 많은 CPU 자원 사용됨

실무
- 디스크 읽기 횟수 많은 경우, 특정 패턴 쿼리 많은 경우(조인, LIKE 패턴 검색), 매우 큰 데이터를 가진 테이블 레코드를 폭 넓게 읽는 경우 = 어댑티브 해시 인덱스 성능 향상 적음
- 디스크 데이터가 버퍼 풀 크기와 비슷한 경우, 동등 조건 검색이 많은 경우, 쿼리가 데이터 중 일부 데이터에만 집중되어 있는 경우 = 어댑티브 해시 인덱스 성능 향상 큼


### 데이터 안정성 및 복구

#### redo 로그 및 redo 로그 버퍼
- 트랜잭션 4가지 요소 중 D(Durable)에 해당하는 영속성과 연관됨
- 비정상적으로 종료됐을 때, 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치
- 비정상 종료가 발생할 경우, redo 로그 내용을 바탕으로 데이터 파일을 종료 직전 상태로 복구함
- 비정상 종료 시 사질 수 있는 데이터 상태
	1. 커밋되었지만 데이터 파일에 기록되지 않은 데이터
	2. 롤백됐지만 데이터 파일에 이미 기록된 데이터
- innodb_log_file_size 시스템 변수로 redo 로그 파일 크기 결정
- innodb_log_files_in_group 시스템 변수로 redo 로그 파일 개수 결정

##### redo 로그 아카이빙
- 데이터 변경이 많아져서 redo 로그가 덮어쓰인다고 하더라도 백업 실패하지 않게 해줌
- log 파일이 로테이션될 때 복사되는 것이 아니라 redo 로그 파일에 로그 엔트리가 추가될 때 함께 기록되는 방식
- 데이터 변경이 발생하면 즉시 아카이빙 로그 파일 크기 늘어남
**실행 방법**
1. innodb_redo_log_archive_dirs 시스템 변수로 디렉터리 설정
2. innodb_redo_log_archive_start UDF 실행 시 아카이빙 기능 실행됨
	- 1개 또는 2개 파라미터 입력 가능 (redo 로그 아카이빙할 디렉터리에 대한 레이블, 서브 디렉터리 이름)
3. innodb_redo_log_archive_stop UDF 실행 시 종료됨
	- 아카이빙 파일도 종료됨 (아카이빙 파일은 그대로 유지)

##### redo 로그 기능 활성화 및 비활성화
- 데이터 파일은 커믹돼도 즉시 디스크로 동기화되지 않는 반면 
  redo 로그 파일은 항상 디스크에 기록됨
- 데이터 복구, 대용량 데이터 적재 시 redo 로그를 비활성화해서 데이터 적재 시간 단축 가능함
- redo 로그 기능 비활성화 시, 마지막 체크 포인트 이후 데이터는 복구할 수 없게 되고 또한 마지막 체크 포인트 시점이 일관된 상태가 아닐 수 있게 됨


#### Double Write 버퍼
- Flush 리스트 플러시할 때, 일부만 기록되는 문제 발생 시, 페이지 내용 복구할 수 없을 수 있음
	- 파셜 페이지(Partial-Page), 톤 페이지(Torn-page) : 페이지 일부만 기록되는 현상
- 플러시하기 전에 더티 페이지를 우선 묶어 한 번의 디스크 쓰기로 시스템 테이블 스페이스의 Double Write 버퍼에 기록, 그 후 적당한 위치에 하나씩 랜덤 쓰기 실행
- 정상 기록 시 필요 없어짐
- InnoDB 스토리지 엔진 재시작 시, 항상 Double Write 버퍼의 내용과 데이터 파일 페이지 모두 비교해서 다른 내용 담고 있는 페이지 있으면 Double Write 버퍼 내용을 데이터 파일의 페이지로 복사함
- innodb_doubleWrite 시스템 변수로 제어 가능

#### 자동화된 장애 복구
- 완료되지 못한 트랜잭션, 디스크 일부만 기록된 데이터 페이지 등에 대한 일련 복구 작업 자동 진행
- innodb_force_recovery 시스템 변수를 설정해서 
  데이터 파일이나 로그 파일 손상 여부 검사 과정을 선별적으로 진행함


### 동시성 제어 및 잠금

#### MVCC(Multi Version Concurrency Control)
- 커밋되지 않은 레코드를 조회하면 격리 수준에 따라 읽는 데이터가 달라지는 것을 의미
	- READ_UNCOMMITTED : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터 읽음(더티 페이지) -> Flush 리스트에 있는 데이터 페이지 읽음
	- READ_COMMITTED 이상 : Undo 로그 영역의 데이터 반환
- 멀티 버전이란 하나의 레코드에 대해 여러 개의 버전이 동시 관리된다는 것을 뜻함
- 잠금 사용하지 않고 일관된 읽기 제공함
- Undo 로그를 이용해 기능 구현

#### 잠금없는 일관된 읽기
- 특정 사용자가 레코드를 변경하고 커밋을 수행하지 않았더라도 변경 트랜잭션이 다른 사용자 SELECT 작업 방해하지 않는 것을 의미함
- MVCC 기술을 통해 잠금 없이 읽기 작업 수행함
- 격리 수준이 SERIALIZABLE이 아닌 READ_UNCOMMITED나 READ_COMMITTED, REPEATABLE_READ 수준일 경우, INSERT 연결되지 않은 순수 읽기 작업은 트랜잭션 변경 작업과 관계없이 항상 잠금 대기하지 않고 실행


#### 자동 데드락 감지
- 내부적으로 잠금이 교착 상태에 빠지지 않도록 잠금 대기 목록을 그래프 형태로 관리
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프 검사해서 교착 상태 빠진 트랜잭션 중 하나를 강제 종료
- Undo 로그가 적은 스레드를 롤백시킴
- innodb_table_locks 시스템 변수 활성화 시, 테이블 레벨 잠금까지 감지 가능
- 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐
	- 해결을 위해서 innodb_deadlock_detect 시스템 변수 제공 : OFF시 데드락 감지 스레드 작동X


#### Undo 로그
- 트랜잭션과 격리 수준 보장을 위해 변경되기 이전 버전의 데이터 별도 백업한 데이터 지칭
- 트랜잭션 롤백 대비용으로 사용됨
- 트랜잭션 격리 수준 유지하면서 높은 동시성 제공함
! 트랜잭션 격리 수준
	동시에 여러 트랜잭션이 데이터 변경, 조회할 때, 한 트랜잭션 작업 내용이 다른 트랜잭션에 어떻게 보일지 결정하는 기준
- MySQL 5.5 미만 버전에서는 한 번 증가한 Undo 로그 공간은 다시 줄어들 지 않음
	- 대용량 데이터 처리 트랜잭션뿐만 아니라 트랜잭션이 오랜 시간동안 실행될 때도 Undo 로그 양 급격히 증가할 수 있음
- MySQL 8.0 에서는 Undo 로그가 돌아가면서 순차적으로 사용함. 때로는 필요 시점에서 사용 공간 자동으로 줄여줌

**실무**
- MySQL 8.0에서 Undo로그 문제점이 상당부분 해결되었더라도 활성 상태 트랜잭션이 장시간 유지되는 것은 성능 상 좋지 않음
- MySQL Undo 로그 건수 확인하는 SQL명령문
```bash
mySQL > SHOW ENGINE INNODB STATUS
```

##### Undo 테이블 스페이스 관리
- Undo 테이블 스페이스 관리란 Undo 로그가 저장되는 공간을 의미
- MySQL 5.6 이전 버전에서는 모두 시스템 테이블스페이스(ibdata.ibd)에 저장됨
- MySQL 5.6 버전에서는 별도의 Undo로그 파일 사용함


##### 구조

### 데이터 저장 방식 및 구조

#### 기본키에 의한 클러스터링
- 기본키(프라이머리 키) 기준 클러스터링(군집)되어 저장
	= 기본키 순서대로 디스크 저장됨
- 모든 세컨더리 인덱스는 기본 키의 논리적 주소로 사용함
- 기본키 포함 모든 인덱스는 물리적인 레코드 주소값을 가짐
- MyISAM 스토리지 엔진에서는 클러스터링 키 지원하지 않음
	= 기본 키와 세컨더리 인덱스 구조적 차이 없음
	= 기본 키 = 유니크 제약을 가진 세컨더리 인덱스

#### 외래키 지원
- 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 
	  변경 시 반드시 부모 테이블이나 자식 테이블에 데이터 있는지 체크하는 작업 필요하므로 잠금이 여러 테이블로 전파됨 => 그로 인해 데드락 발생 많아짐
- foreign_key_checks 시스템 변수 : OFF 시 외래 키 관계에 대한 체크 작업 일시 정지함
	= ON DELETE CASCADE와 ON UPDATE CASCADE 옵션 무시하게 됨
- MyISAM이나 MEMORY 테이블에서 사용 불가









