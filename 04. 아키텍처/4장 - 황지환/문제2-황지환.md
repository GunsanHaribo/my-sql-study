# 문제
1. MySQL 엔진은 SQL 파싱, 옵티마이징, 실행 계획 생성을 담당하지만, 실제 디스크에 데이터 페이지를 쓰는 역할은 하지 않는다. (O/X)
2. MySQL 엔진과 스토리지 엔진은 핸들러 API를 통해 통신한다. (O/X)
3. 글로벌 메모리 영역에는 InnoDB 버퍼 풀, 테이블 캐시, 리두 로그 버퍼 등이 포함된다. (O/X)
4. InnoDB 버퍼 풀의 Free 리스트는 아직 채워지지 않은 비어 있는 페이지들을 관리한다. (O/X)
5. Consistent Read(잠금 없는 일관된 읽기)는 언두 로그를 이용해 구현된다. (O/X)
6. 어댑티브 해시 인덱스(AHI)는 버퍼 풀에 적재된 페이지들에 대해서만 동작한다. (O/X)
7. MySQL 8에서는 쿼리 캐시(Query Cache)가 성능 향상에 도움이 되므로 기본 활성화를 권장한다. (O/X)
8. InnoDB는 프라이머리 키를 지정하면 해당 키 순서대로 데이터가 정렬·저장되며, 이를 (   ) 인덱스라고 한다.
9. InnoDB의 체인지 버퍼는 버퍼 풀에 없는 (   ) 페이지의 변경을 모아두었다가 나중에 병합 적용한다.
10. Flush List 플러시는 오래된 리두 로그를 재활용하기 위해 (   ) 페이지를 디스크에 먼저 내려보내는 메커니즘이다.

----

# 답지 
1. O (스토리지 엔진이 디스크 I/O 담당)
2. O
3. O
4. O
5. O (언두 로그 기반 MVCC)
6. O
7. X (MySQL 8에서는 Query Cache가 제거됨)
8. 클러스터드(Clustered)
9. 인덱스
10. 더티(Dirty)

----

# 학습해야할것 + 버퍼풀
```text
MySQL 학습에서 가장 먼저 짚어야 할 부분은 로그 시스템입니다. 제너럴 로그는 쿼리를 실행한 뒤가 아니라 요청을 받자마자 기록한다는 점이 중요하며, 실행 성공 여부와 관계없이 모두 남기기 때문에 주로 디버깅용으로 활용됩니다. 반면 슬로우 쿼리 로그는 long_query_time 이상 걸린 쿼리만 기록되고, 반드시 정상적으로 실행이 끝나야 기록됩니다. 즉, 에러가 난 쿼리는 포함되지 않습니다. 에러 로그는 서버의 시작과 종료, 에러 메시지 등이 남는 곳으로, 별도 경로를 지정하지 않으면 데이터 디렉토리에 .err 확장자 파일로 생성됩니다. 따라서 로그를 정리할 때는 기록 시점(요청 시점인지 실행 후인지), 기록 대상(모든 쿼리인지 느린 쿼리인지 에러인지), 저장 위치까지 함께 표로 정리해두면 확실히 도움이 됩니다.

다음으로 MyISAM 엔진의 특성을 이해할 필요가 있습니다. MyISAM은 인덱스 디스크 쓰기만 부분적으로 버퍼링하고, 데이터 파일은 운영체제의 캐시에 의존합니다. 데이터 파일 자체는 힙 공간처럼 활용되며, 각 레코드는 물리적인 주솟값인 ROWID를 갖습니다. 읽기와 쓰기 요청은 항상 운영체제 수준의 디스크 I/O로 직접 연결되기 때문에 빠른 읽기에 강점이 있습니다. 이를 InnoDB와 비교하면 차이가 분명해집니다. InnoDB는 버퍼 풀과 클러스터드 인덱스를 사용하며 트랜잭션을 지원하는 반면, MyISAM은 트랜잭션을 지원하지 않고 OS 캐시에만 의존합니다.

또 하나 중요한 부분은 잠금 메커니즘입니다. MyISAM과 MEMORY 엔진은 별도의 스토리지 엔진 레벨 잠금이 존재하지 않고 테이블 단위 잠금만 제공하는 반면, InnoDB는 레코드 단위 잠금을 지원합니다. 이 차이 때문에 동시성 처리나 성능에서 두 엔진의 활용도가 크게 달라집니다.

결국 학습해야 할 핵심은 네 가지로 정리됩니다. 첫째, MySQL 로그 시스템의 종류와 차이(General, Slow, Error 로그의 기록 시점·조건·위치). 둘째, MyISAM의 동작 방식(버퍼링 범위, 데이터 파일 구조, ROWID, I/O 특성). 셋째, InnoDB와 MyISAM의 비교(트랜잭션 지원 여부, 잠금 단위, 캐싱 구조). 넷째, 스토리지 엔진별 잠금 메커니즘입니다.
```